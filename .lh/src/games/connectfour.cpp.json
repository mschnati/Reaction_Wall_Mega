{
    "sourceFile": "src/games/connectfour.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1740907888512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740907944060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,17 +5,8 @@\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n-// Game state for Connect Four\r\n-struct ConnectFourState {\r\n-    int board[6][6];       // 0 = empty, 1 = player1, 2 = player2\r\n-    uint8_t currentPlayer; // 1 or 2\r\n-    bool isActive;\r\n-    unsigned long lastUpdate;\r\n-    bool hasWinner;\r\n-};\r\n-\r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n void setCellColor(int row, int col, CRGB color) {\r\n     // Use the existing function to light the button at that coordinate.\r\n     setButtonColor(row, col, color);\r\n"
                },
                {
                    "date": 1740907949604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n \r\n+\r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n"
                },
                {
                    "date": 1740907954657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n+#inclute \r\n \r\n-\r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n"
                },
                {
                    "date": 1740907993994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n-#inclute \r\n \r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n"
                },
                {
                    "date": 1740908521688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,17 +42,56 @@\n static bool check_win(ConnectFourState* state) {\r\n     for (int row = 0; row < 6; row++) {\r\n         for (int col = 0; col < 6; col++) {\r\n             if (state->board[row][col] != 0) {\r\n-                // Check horizontally, vertically, and both diagonals.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1))\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0))\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n                     return true;\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1))\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1))\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n+                }\r\n             }\r\n         }\r\n     }\r\n     return false;\r\n"
                },
                {
                    "date": 1740908559589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,13 +160,13 @@\n                 \r\n                 // Check for win.\r\n                 if (check_win(state)) {\r\n                     state->hasWinner = true;\r\n-                    // Highlight winning board (for simplicity, fill entire board with WIN_COLOR).\r\n-                    for (int r = 0; r < 6; r++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            setCellColor(r, c, WIN_COLOR);\r\n-                        }\r\n+                    // Light up only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n                     }\r\n                     FastLED.show();\r\n                     delay(WIN_DISPLAY_TIME);\r\n                     state->isActive = false;\r\n"
                },
                {
                    "date": 1740908681423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,16 +153,34 @@\n                     break;\r\n                 }\r\n             }\r\n             if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n                 state->board[dropRow][col] = state->currentPlayer;\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                setCellColor(dropRow, col, moveColor);\r\n                 \r\n                 // Check for win.\r\n                 if (check_win(state)) {\r\n                     state->hasWinner = true;\r\n-                    // Light up only the winning pieces in green.\r\n+                    // Highlight only the winning pieces in green.\r\n                     for (int i = 0; i < 4; i++) {\r\n                         int r = state->winningCells[i][0];\r\n                         int c = state->winningCells[i][1];\r\n                         setCellColor(r, c, WIN_COLOR);\r\n"
                }
            ],
            "date": 1740907888512,
            "name": "Commit-0",
            "content": "#include \"globals.h\"\r\n#include <string.h>\r\n\r\n#define PLAYER_1_COLOR CRGB::Red\r\n#define PLAYER_2_COLOR CRGB::Blue\r\n#define WIN_COLOR CRGB::Green\r\n#define WIN_DISPLAY_TIME 3000\r\n\r\n// Game state for Connect Four\r\nstruct ConnectFourState {\r\n    int board[6][6];       // 0 = empty, 1 = player1, 2 = player2\r\n    uint8_t currentPlayer; // 1 or 2\r\n    bool isActive;\r\n    unsigned long lastUpdate;\r\n    bool hasWinner;\r\n};\r\n\r\n// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\nvoid setCellColor(int row, int col, CRGB color) {\r\n    // Use the existing function to light the button at that coordinate.\r\n    setButtonColor(row, col, color);\r\n}\r\n\r\n// Initialize the Connect Four board.\r\nvoid connectfour_init(ConnectFourState* state) {\r\n    memset(state->board, 0, sizeof(state->board));\r\n    state->currentPlayer = 1;\r\n    state->isActive = false;\r\n    state->lastUpdate = 0;\r\n    state->hasWinner = false;\r\n    // Optionally clear the display:\r\n    FastLED.clear();\r\n    FastLED.show();\r\n}\r\n\r\n// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\nstatic bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n    int player = state->board[row][col];\r\n    for (int i = 1; i < 4; i++) {\r\n        int newRow = row + i * dRow;\r\n        int newCol = col + i * dCol;\r\n        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n           state->board[newRow][newCol] != player) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Check if the current board has a win.\r\nstatic bool check_win(ConnectFourState* state) {\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            if (state->board[row][col] != 0) {\r\n                // Check horizontally, vertically, and both diagonals.\r\n                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1))\r\n                    return true;\r\n                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0))\r\n                    return true;\r\n                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1))\r\n                    return true;\r\n                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// Check if the board is full\r\nstatic bool check_draw(ConnectFourState* state) {\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            if (state->board[row][col] == 0) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Helper: Check if any button in the given column is pressed.\r\n// We check all rows in that column. Use your existing checkButton function.\r\nstatic bool columnPressed(int col) {\r\n    for (int row = 0; row < 6; row++) {\r\n        int btnID = ButtonMatrix[row][col];\r\n        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Update the Connect Four game state.\r\n * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n */\r\nvoid connectfour_update(ConnectFourState* state) {\r\n    if (!state->isActive) return;\r\n\r\n    FastLED.clear();\r\n\r\n    // Draw the board pieces.\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            int cell = state->board[row][col];\r\n            if (cell == 1) {\r\n                setCellColor(row, col, PLAYER_1_COLOR);\r\n            }\r\n            else if (cell == 2) {\r\n                setCellColor(row, col, PLAYER_2_COLOR);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check input for each column.\r\n    for (int col = 0; col < 6; col++) {\r\n        if (columnPressed(col)) {\r\n            // Only process one column at a time (debounce).\r\n            // Find the lowest empty cell in this column.\r\n            int dropRow = -1;\r\n            for (int row = 0; row < 6; row++) {\r\n                if (state->board[row][col] == 0) {\r\n                    dropRow = row;\r\n                    break;\r\n                }\r\n            }\r\n            if (dropRow != -1) {\r\n                state->board[dropRow][col] = state->currentPlayer;\r\n                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n                setCellColor(dropRow, col, moveColor);\r\n                \r\n                // Check for win.\r\n                if (check_win(state)) {\r\n                    state->hasWinner = true;\r\n                    // Highlight winning board (for simplicity, fill entire board with WIN_COLOR).\r\n                    for (int r = 0; r < 6; r++) {\r\n                        for (int c = 0; c < 6; c++) {\r\n                            setCellColor(r, c, WIN_COLOR);\r\n                        }\r\n                    }\r\n                    FastLED.show();\r\n                    delay(WIN_DISPLAY_TIME);\r\n                    state->isActive = false;\r\n                    return;\r\n                }\r\n                else if (check_draw(state)) {\r\n                    // In case of a draw, just clear after a short delay.\r\n                    FastLED.show();\r\n                    delay(1000);\r\n                    state->isActive = false;\r\n                    FastLED.clear();\r\n                    FastLED.show();\r\n                    return;\r\n                }\r\n                \r\n                // Switch players.\r\n                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n                // Pause briefly to debounce input.\r\n                delay(250);\r\n                break; // Process one move per update.\r\n            }\r\n        }\r\n    }\r\n\r\n    FastLED.show();\r\n}\r\n\r\n/**\r\n * Start the Connect Four game.\r\n */\r\nvoid connectfour_start(ConnectFourState* state) {\r\n    connectfour_init(state);\r\n    // Optional extra delay for debouncing before starting.\r\n    delay(500);\r\n    state->isActive = true;\r\n}\r\n\r\n/**\r\n * Check if the Connect Four game is running.\r\n */\r\nbool connectfour_is_running(ConnectFourState* state) {\r\n    return state->isActive;\r\n}"
        }
    ]
}