{
    "sourceFile": "src/games/connectfour.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 42,
            "patches": [
                {
                    "date": 1740907888512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740907944060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,17 +5,8 @@\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n-// Game state for Connect Four\r\n-struct ConnectFourState {\r\n-    int board[6][6];       // 0 = empty, 1 = player1, 2 = player2\r\n-    uint8_t currentPlayer; // 1 or 2\r\n-    bool isActive;\r\n-    unsigned long lastUpdate;\r\n-    bool hasWinner;\r\n-};\r\n-\r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n void setCellColor(int row, int col, CRGB color) {\r\n     // Use the existing function to light the button at that coordinate.\r\n     setButtonColor(row, col, color);\r\n"
                },
                {
                    "date": 1740907949604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n \r\n+\r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n"
                },
                {
                    "date": 1740907954657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n+#inclute \r\n \r\n-\r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n"
                },
                {
                    "date": 1740907993994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n-#inclute \r\n \r\n #define PLAYER_1_COLOR CRGB::Red\r\n #define PLAYER_2_COLOR CRGB::Blue\r\n #define WIN_COLOR CRGB::Green\r\n"
                },
                {
                    "date": 1740908521688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,17 +42,56 @@\n static bool check_win(ConnectFourState* state) {\r\n     for (int row = 0; row < 6; row++) {\r\n         for (int col = 0; col < 6; col++) {\r\n             if (state->board[row][col] != 0) {\r\n-                // Check horizontally, vertically, and both diagonals.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1))\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0))\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n                     return true;\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1))\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1))\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n                     return true;\r\n+                }\r\n             }\r\n         }\r\n     }\r\n     return false;\r\n"
                },
                {
                    "date": 1740908559589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,13 +160,13 @@\n                 \r\n                 // Check for win.\r\n                 if (check_win(state)) {\r\n                     state->hasWinner = true;\r\n-                    // Highlight winning board (for simplicity, fill entire board with WIN_COLOR).\r\n-                    for (int r = 0; r < 6; r++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            setCellColor(r, c, WIN_COLOR);\r\n-                        }\r\n+                    // Light up only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n                     }\r\n                     FastLED.show();\r\n                     delay(WIN_DISPLAY_TIME);\r\n                     state->isActive = false;\r\n"
                },
                {
                    "date": 1740908681423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,16 +153,34 @@\n                     break;\r\n                 }\r\n             }\r\n             if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n                 state->board[dropRow][col] = state->currentPlayer;\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                setCellColor(dropRow, col, moveColor);\r\n                 \r\n                 // Check for win.\r\n                 if (check_win(state)) {\r\n                     state->hasWinner = true;\r\n-                    // Light up only the winning pieces in green.\r\n+                    // Highlight only the winning pieces in green.\r\n                     for (int i = 0; i < 4; i++) {\r\n                         int r = state->winningCells[i][0];\r\n                         int c = state->winningCells[i][1];\r\n                         setCellColor(r, c, WIN_COLOR);\r\n"
                },
                {
                    "date": 1741197798452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,230 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Blue\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741198019434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,231 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Blue\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    \r\n+    state->isActive = true;\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741198026478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,231 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Blue\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while \r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741198034214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,704 +219,15 @@\n     connectfour_init(state);\r\n     // Optional extra delay for debouncing before starting.\r\n     delay(500);\r\n     state->isActive = true;\r\n-    while \r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Blue\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n+    while (anyButtonPressed()) {\r\n+        \r\n     }\r\n-    return true;\r\n }\r\n \r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n /**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    \r\n-    state->isActive = true;\r\n-}\r\n-\r\n-/**\r\n  * Check if the Connect Four game is running.\r\n  */\r\n bool connectfour_is_running(ConnectFourState* state) {\r\n     return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Blue\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Blue\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-           state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741198194382,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n #include \"globals.h\"\r\n #include <string.h>\r\n \r\n #define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Blue\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n@@ -220,9 +220,9 @@\n     // Optional extra delay for debouncing before starting.\r\n     delay(500);\r\n     state->isActive = true;\r\n     while (anyButtonPressed()) {\r\n-        \r\n+        delay(10);\r\n     }\r\n }\r\n \r\n /**\r\n"
                },
                {
                    "date": 1741200258314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    \r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200292772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,9 +185,9 @@\n                         int c = state->winningCells[i][1];\r\n                         setCellColor(r, c, WIN_COLOR);\r\n                     }\r\n                     FastLED.show();\r\n-                    \r\n+                    if ()\r\n                     delay(WIN_DISPLAY_TIME);\r\n                     state->isActive = false;\r\n                     return;\r\n                 }\r\n@@ -230,238 +230,5 @@\n  * Check if the Connect Four game is running.\r\n  */\r\n bool connectfour_is_running(ConnectFourState* state) {\r\n     return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200303052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,239 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    \r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200308613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,240 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200403136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,10 @@\n #define PLAYER_2_COLOR CRGB::Yellow\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n+\r\n+\r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n void setCellColor(int row, int col, CRGB color) {\r\n     // Use the existing function to light the button at that coordinate.\r\n     setButtonColor(row, col, color);\r\n"
                },
                {
                    "date": 1741200419954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,243 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+int previousPlayer = 1;\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200432261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,8 +130,10 @@\n     if (!state->isActive) return;\r\n \r\n     FastLED.clear();\r\n \r\n+    \r\n+\r\n     // Draw the board pieces.\r\n     for (int row = 0; row < 6; row++) {\r\n         for (int col = 0; col < 6; col++) {\r\n             int cell = state->board[row][col];\r\n"
                },
                {
                    "date": 1741200437808,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n     state->hasWinner = false;\r\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n-    \r\n+    previousPlayer = 1;\r\n }\r\n \r\n // Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n@@ -130,9 +130,9 @@\n     if (!state->isActive) return;\r\n \r\n     FastLED.clear();\r\n \r\n-    \r\n+    // S\r\n \r\n     // Draw the board pieces.\r\n     for (int row = 0; row < 6; row++) {\r\n         for (int col = 0; col < 6; col++) {\r\n@@ -241,720 +241,5 @@\n  * Check if the Connect Four game is running.\r\n  */\r\n bool connectfour_is_running(ConnectFourState* state) {\r\n     return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    \r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if ()\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200446906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,246 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+int previousPlayer = 1;\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    previousPlayer = 1;\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if \r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(250);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200486901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n #define PLAYER_2_COLOR CRGB::Yellow\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n-int previousPlayer = 1;\r\n+int prevFourPlayer = 1;\r\n \r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n void setCellColor(int row, int col, CRGB color) {\r\n     // Use the existing function to light the button at that coordinate.\r\n"
                },
                {
                    "date": 1741200501567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n     state->hasWinner = false;\r\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n-    previousPlayer = 1;\r\n+    prevFourPlayer = 1;\r\n }\r\n \r\n // Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n@@ -131,255 +131,15 @@\n \r\n     FastLED.clear();\r\n \r\n     // Show the current player's turn.\r\n-    if \r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n     }\r\n \r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(250);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-int previousPlayer = 1;\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    previousPlayer = 1;\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // S\r\n-\r\n     // Draw the board pieces.\r\n     for (int row = 0; row < 6; row++) {\r\n         for (int col = 0; col < 6; col++) {\r\n             int cell = state->board[row][col];\r\n"
                },
                {
                    "date": 1741200518712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -218,8 +218,9 @@\n                     return;\r\n                 }\r\n                 \r\n                 // Switch players.\r\n+                \r\n                 state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n                 // Pause briefly to debounce input.\r\n                 delay(250);\r\n                 break; // Process one move per update.\r\n"
                },
                {
                    "date": 1741200527611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,252 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+int prevFourPlayer = 1;\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    prevFourPlayer = 1;\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n+    }\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741200597626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,262 +24,14 @@\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n     prevFourPlayer = 1;\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n+    char message[16];\r\n         sprintf(message, \"Player %d\", state->currentPlayer);\r\n         updateDisplay(\"Connect Four\", 0, 10);\r\n         updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n }\r\n \r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-int prevFourPlayer = 1;\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    prevFourPlayer = 1;\r\n-}\r\n-\r\n // Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n     int player = state->board[row][col];\r\n     for (int i = 1; i < 4; i++) {\r\n@@ -470,12 +222,12 @@\n                     return;\r\n                 }\r\n                 \r\n                 // Switch players.\r\n-                \r\n+                prevFourPlayer = state->currentPlayer;\r\n                 state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n                 // Pause briefly to debounce input.\r\n-                delay(250);\r\n+                delay(100);\r\n                 break; // Process one move per update.\r\n             }\r\n         }\r\n     }\r\n"
                },
                {
                    "date": 1741200604332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,10 +26,10 @@\n     FastLED.show();\r\n     prevFourPlayer = 1;\r\n     char message[16];\r\n         sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(message, 3, 8);\r\n }\r\n \r\n // Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n"
                },
                {
                    "date": 1741200705120,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,11 +23,12 @@\n     state->hasWinner = false;\r\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n+    \r\n     prevFourPlayer = 1;\r\n     char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+    sprintf(message, \"Player %d\", state->currentPlayer);\r\n     updateDisplay(\"Connect Four\", 0, 10);\r\n     updateDisplay(message, 3, 8);\r\n }\r\n \r\n"
                },
                {
                    "date": 1741202621320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,8 @@\n #define PLAYER_2_COLOR CRGB::Yellow\r\n #define WIN_COLOR CRGB::Green\r\n #define WIN_DISPLAY_TIME 3000\r\n \r\n-int prevFourPlayer = 1;\r\n-\r\n // Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n void setCellColor(int row, int col, CRGB color) {\r\n     // Use the existing function to light the button at that coordinate.\r\n     setButtonColor(row, col, color);\r\n"
                },
                {
                    "date": 1741202629155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,8 @@\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n     \r\n-    prevFourPlayer = 1;\r\n     char message[16];\r\n     sprintf(message, \"Player %d\", state->currentPlayer);\r\n     updateDisplay(\"Connect Four\", 0, 10);\r\n     updateDisplay(message, 3, 8);\r\n"
                },
                {
                    "date": 1741202636316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,9 @@\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n     \r\n+    \r\n     char message[16];\r\n     sprintf(message, \"Player %d\", state->currentPlayer);\r\n     updateDisplay(\"Connect Four\", 0, 10);\r\n     updateDisplay(message, 3, 8);\r\n"
                },
                {
                    "date": 1741202642333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,255 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    u8\r\n+    char message[16];\r\n+    sprintf(message, \"Player %d\", state->currentPlayer);\r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(message, 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n+    }\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202658428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,254 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    char message[16];\r\n+    sprintf(message, \"Player %d\", state->currentPlayer);\r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(message, 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n+    }\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202674659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,254 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    char message[16];\r\n+    sprintf(message, \"Red's turn %d\", state->currentPlayer);\r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(message, 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n+    }\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202693486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,254 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    char message[16];\r\n+    sprintf(message, \"Red's turn %d\", state->currentPlayer);\r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(\"message\", 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Show the current player's turn.\r\n+    if (state->currentPlayer != prevFourPlayer) {\r\n+        char message[16];\r\n+        sprintf(message, \"Player %d\", state->currentPlayer);\r\n+        updateDisplay(\"Connect Four\", 0, 10);\r\n+        updateDisplay(message, 3, 8);\r\n+    }\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202699038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,12 +22,10 @@\n     // Optionally clear the display:\r\n     FastLED.clear();\r\n     FastLED.show();\r\n     \r\n-    char message[16];\r\n-    sprintf(message, \"Red's turn %d\", state->currentPlayer);\r\n     updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(\"message\", 3, 8);\r\n+    updateDisplay(\"Red's turn\", 3, 8);\r\n }\r\n \r\n // Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n@@ -250,1023 +248,5 @@\n  * Check if the Connect Four game is running.\r\n  */\r\n bool connectfour_is_running(ConnectFourState* state) {\r\n     return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    \r\n-    char message[16];\r\n-    sprintf(message, \"Red's turn %d\", state->currentPlayer);\r\n-    updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(message, 3, 8);\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    \r\n-    char message[16];\r\n-    sprintf(message, \"Player %d\", state->currentPlayer);\r\n-    updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(message, 3, 8);\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    \r\n-    u8\r\n-    char message[16];\r\n-    sprintf(message, \"Player %d\", state->currentPlayer);\r\n-    updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(message, 3, 8);\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    \r\n-    \r\n-    char message[16];\r\n-    sprintf(message, \"Player %d\", state->currentPlayer);\r\n-    updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(message, 3, 8);\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n-                \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n-                \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202714656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,244 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(\"Red's turn\", 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                prevFourPlayer = state->currentPlayer;\r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202729679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,261 +210,10 @@\n                     return;\r\n                 }\r\n                 \r\n                 // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n-                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n-                // Pause briefly to debounce input.\r\n-                delay(100);\r\n-                break; // Process one move per update.\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-}\r\n-\r\n-/**\r\n- * Start the Connect Four game.\r\n- */\r\n-void connectfour_start(ConnectFourState* state) {\r\n-    connectfour_init(state);\r\n-    // Optional extra delay for debouncing before starting.\r\n-    delay(500);\r\n-    state->isActive = true;\r\n-    while (anyButtonPressed()) {\r\n-        delay(10);\r\n-    }\r\n-}\r\n-\r\n-/**\r\n- * Check if the Connect Four game is running.\r\n- */\r\n-bool connectfour_is_running(ConnectFourState* state) {\r\n-    return state->isActive;\r\n-}\n-#include \"globals.h\"\r\n-#include <string.h>\r\n-\r\n-#define PLAYER_1_COLOR CRGB::Red\r\n-#define PLAYER_2_COLOR CRGB::Yellow\r\n-#define WIN_COLOR CRGB::Green\r\n-#define WIN_DISPLAY_TIME 3000\r\n-\r\n-// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n-void setCellColor(int row, int col, CRGB color) {\r\n-    // Use the existing function to light the button at that coordinate.\r\n-    setButtonColor(row, col, color);\r\n-}\r\n-\r\n-// Initialize the Connect Four board.\r\n-void connectfour_init(ConnectFourState* state) {\r\n-    memset(state->board, 0, sizeof(state->board));\r\n-    state->currentPlayer = 1;\r\n-    state->isActive = false;\r\n-    state->lastUpdate = 0;\r\n-    state->hasWinner = false;\r\n-    // Optionally clear the display:\r\n-    FastLED.clear();\r\n-    FastLED.show();\r\n-    \r\n-    updateDisplay(\"Connect Four\", 0, 10);\r\n-    updateDisplay(\"Red's turn\", 3, 8);\r\n-}\r\n-\r\n-// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n-static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n-    int player = state->board[row][col];\r\n-    for (int i = 1; i < 4; i++) {\r\n-        int newRow = row + i * dRow;\r\n-        int newCol = col + i * dCol;\r\n-        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n-            state->board[newRow][newCol] != player) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Check if the current board has a win.\r\n-static bool check_win(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] != 0) {\r\n-                // Check horizontally.\r\n-                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check vertically.\r\n-                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (down-right).\r\n-                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row + 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row + 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row + 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-                // Check diagonal (up-right).\r\n-                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n-                    state->winningCells[0][0] = row;\r\n-                    state->winningCells[0][1] = col;\r\n-                    state->winningCells[1][0] = row - 1;\r\n-                    state->winningCells[1][1] = col + 1;\r\n-                    state->winningCells[2][0] = row - 2;\r\n-                    state->winningCells[2][1] = col + 2;\r\n-                    state->winningCells[3][0] = row - 3;\r\n-                    state->winningCells[3][1] = col + 3;\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-// Check if the board is full\r\n-static bool check_draw(ConnectFourState* state) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            if (state->board[row][col] == 0) return false;\r\n-        }\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Helper: Check if any button in the given column is pressed.\r\n-// We check all rows in that column. Use your existing checkButton function.\r\n-static bool columnPressed(int col) {\r\n-    for (int row = 0; row < 6; row++) {\r\n-        int btnID = ButtonMatrix[row][col];\r\n-        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n-            return true;\r\n-        }\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-/**\r\n- * Update the Connect Four game state.\r\n- * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n- */\r\n-void connectfour_update(ConnectFourState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    FastLED.clear();\r\n-\r\n-    // Show the current player's turn.\r\n-    if (state->currentPlayer != prevFourPlayer) {\r\n-        char message[16];\r\n-        sprintf(message, \"Player %d\", state->currentPlayer);\r\n-        updateDisplay(\"Connect Four\", 0, 10);\r\n-        updateDisplay(message, 3, 8);\r\n-    }\r\n-\r\n-    // Draw the board pieces.\r\n-    for (int row = 0; row < 6; row++) {\r\n-        for (int col = 0; col < 6; col++) {\r\n-            int cell = state->board[row][col];\r\n-            if (cell == 1) {\r\n-                setCellColor(row, col, PLAYER_1_COLOR);\r\n-            }\r\n-            else if (cell == 2) {\r\n-                setCellColor(row, col, PLAYER_2_COLOR);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    // Check input for each column.\r\n-    for (int col = 0; col < 6; col++) {\r\n-        if (columnPressed(col)) {\r\n-            // Only process one column at a time (debounce).\r\n-            // Find the lowest empty cell in this column.\r\n-            int dropRow = -1;\r\n-            for (int row = 0; row < 6; row++) {\r\n-                if (state->board[row][col] == 0) {\r\n-                    dropRow = row;\r\n-                    break;\r\n-                }\r\n-            }\r\n-            if (dropRow != -1) {\r\n-                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-            \r\n-                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n-                for (int r = 5; r >= dropRow; r--) {\r\n-                    FastLED.clear();\r\n-                    // Redraw the static board pieces.\r\n-                    for (int row = 0; row < 6; row++) {\r\n-                        for (int c = 0; c < 6; c++) {\r\n-                            if (state->board[row][c] != 0) {\r\n-                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n-                                setCellColor(row, c, color);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    // Draw the falling piece at the current animation row.\r\n-                    setCellColor(r, col, moveColor);\r\n-                    FastLED.show();\r\n-                    delay(50);\r\n-                }\r\n-                // After animation, commit the move to the board.\r\n-                state->board[dropRow][col] = state->currentPlayer;\r\n                 \r\n-                // Check for win.\r\n-                if (check_win(state)) {\r\n-                    state->hasWinner = true;\r\n-                    // Highlight only the winning pieces in green.\r\n-                    for (int i = 0; i < 4; i++) {\r\n-                        int r = state->winningCells[i][0];\r\n-                        int c = state->winningCells[i][1];\r\n-                        setCellColor(r, c, WIN_COLOR);\r\n-                    }\r\n-                    FastLED.show();\r\n-                    if (state->currentPlayer == 1) {\r\n-                        updateDisplay(\"Red wins!\", 5, 8);\r\n-                    } else {\r\n-                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n-                    }\r\n-                    delay(WIN_DISPLAY_TIME);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    u8g2.clearBuffer();\r\n-                    return;\r\n-                }\r\n-                else if (check_draw(state)) {\r\n-                    // In case of a draw, just clear after a short delay.\r\n-                    FastLED.show();\r\n-                    delay(1000);\r\n-                    state->isActive = false;\r\n-                    FastLED.clear();\r\n-                    FastLED.show();\r\n-                    return;\r\n-                }\r\n                 \r\n-                // Switch players.\r\n-                prevFourPlayer = state->currentPlayer;\r\n                 state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n                 // Pause briefly to debounce input.\r\n                 delay(100);\r\n                 break; // Process one move per update.\r\n"
                },
                {
                    "date": 1741202819867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,251 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(\"Red's turn\", 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                if (state->currentPlayer == 1) {\r\n+                    u8g2.clearBuffer();\r\n+                    \r\n+                    updateDisplay(\"Yellow's turn\", 3, 8);\r\n+                } else {\r\n+                    updateDisplay(\"Red's turn\", 3, 8);\r\n+                }\r\n+                \r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202827798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,251 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(\"Red's turn\", 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                if (state->currentPlayer == 1) {\r\n+                    u8g2.clearBuffer();\r\n+                    updateDisplay(\"C\")\r\n+                    updateDisplay(\"Yellow's turn\", 3, 8);\r\n+                } else {\r\n+                    updateDisplay(\"Red's turn\", 3, 8);\r\n+                }\r\n+                \r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741202833406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,8 +215,10 @@\n                     u8g2.clearBuffer();\r\n                     updateDisplay(\"Connect Four\", 0, 10);\r\n                     updateDisplay(\"Yellow's turn\", 3, 8);\r\n                 } else {\r\n+                    u8g2.clearBuffer();\r\n+                    updateDisplay(\"Connect Four\", 0, 10);\r\n                     updateDisplay(\"Red's turn\", 3, 8);\r\n                 }\r\n                 \r\n                 state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n"
                },
                {
                    "date": 1741202894629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,255 @@\n+#include \"globals.h\"\r\n+#include <string.h>\r\n+\r\n+#define PLAYER_1_COLOR CRGB::Red\r\n+#define PLAYER_2_COLOR CRGB::Yellow\r\n+#define WIN_COLOR CRGB::Green\r\n+#define WIN_DISPLAY_TIME 3000\r\n+\r\n+// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\n+void setCellColor(int row, int col, CRGB color) {\r\n+    // Use the existing function to light the button at that coordinate.\r\n+    setButtonColor(row, col, color);\r\n+}\r\n+\r\n+// Initialize the Connect Four board.\r\n+void connectfour_init(ConnectFourState* state) {\r\n+    memset(state->board, 0, sizeof(state->board));\r\n+    state->currentPlayer = 1;\r\n+    state->isActive = false;\r\n+    state->lastUpdate = 0;\r\n+    state->hasWinner = false;\r\n+    // Optionally clear the display:\r\n+    FastLED.clear();\r\n+    FastLED.show();\r\n+    \r\n+    updateDisplay(\"Connect Four\", 0, 10);\r\n+    updateDisplay(\"Red's turn\", 3, 8);\r\n+}\r\n+\r\n+// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\n+static bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n+    int player = state->board[row][col];\r\n+    for (int i = 1; i < 4; i++) {\r\n+        int newRow = row + i * dRow;\r\n+        int newCol = col + i * dCol;\r\n+        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n+            state->board[newRow][newCol] != player) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Check if the current board has a win.\r\n+static bool check_win(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] != 0) {\r\n+                // Check horizontally.\r\n+                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check vertically.\r\n+                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (down-right).\r\n+                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row + 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row + 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row + 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+                // Check diagonal (up-right).\r\n+                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1)) {\r\n+                    state->winningCells[0][0] = row;\r\n+                    state->winningCells[0][1] = col;\r\n+                    state->winningCells[1][0] = row - 1;\r\n+                    state->winningCells[1][1] = col + 1;\r\n+                    state->winningCells[2][0] = row - 2;\r\n+                    state->winningCells[2][1] = col + 2;\r\n+                    state->winningCells[3][0] = row - 3;\r\n+                    state->winningCells[3][1] = col + 3;\r\n+                    return true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+// Check if the board is full\r\n+static bool check_draw(ConnectFourState* state) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            if (state->board[row][col] == 0) return false;\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Helper: Check if any button in the given column is pressed.\r\n+// We check all rows in that column. Use your existing checkButton function.\r\n+static bool columnPressed(int col) {\r\n+    for (int row = 0; row < 6; row++) {\r\n+        int btnID = ButtonMatrix[row][col];\r\n+        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n+            return true;\r\n+        }\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+/**\r\n+ * Update the Connect Four game state.\r\n+ * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n+ */\r\n+void connectfour_update(ConnectFourState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    FastLED.clear();\r\n+\r\n+    // Draw the board pieces.\r\n+    for (int row = 0; row < 6; row++) {\r\n+        for (int col = 0; col < 6; col++) {\r\n+            int cell = state->board[row][col];\r\n+            if (cell == 1) {\r\n+                setCellColor(row, col, PLAYER_1_COLOR);\r\n+            }\r\n+            else if (cell == 2) {\r\n+                setCellColor(row, col, PLAYER_2_COLOR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // Check input for each column.\r\n+    for (int col = 0; col < 6; col++) {\r\n+        if (columnPressed(col)) {\r\n+            // Only process one column at a time (debounce).\r\n+            // Find the lowest empty cell in this column.\r\n+            int dropRow = -1;\r\n+            for (int row = 0; row < 6; row++) {\r\n+                if (state->board[row][col] == 0) {\r\n+                    dropRow = row;\r\n+                    break;\r\n+                }\r\n+            }\r\n+            if (dropRow != -1) {\r\n+                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+            \r\n+                // Animate the falling piece from the top (row 5) down to the dropRow.\r\n+                for (int r = 5; r >= dropRow; r--) {\r\n+                    FastLED.clear();\r\n+                    // Redraw the static board pieces.\r\n+                    for (int row = 0; row < 6; row++) {\r\n+                        for (int c = 0; c < 6; c++) {\r\n+                            if (state->board[row][c] != 0) {\r\n+                                CRGB color = (state->board[row][c] == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n+                                setCellColor(row, c, color);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    // Draw the falling piece at the current animation row.\r\n+                    setCellColor(r, col, moveColor);\r\n+                    FastLED.show();\r\n+                    delay(50);\r\n+                }\r\n+                // After animation, commit the move to the board.\r\n+                state->board[dropRow][col] = state->currentPlayer;\r\n+                \r\n+                // Check for win.\r\n+                if (check_win(state)) {\r\n+                    state->hasWinner = true;\r\n+                    // Highlight only the winning pieces in green.\r\n+                    for (int i = 0; i < 4; i++) {\r\n+                        int r = state->winningCells[i][0];\r\n+                        int c = state->winningCells[i][1];\r\n+                        setCellColor(r, c, WIN_COLOR);\r\n+                    }\r\n+                    FastLED.show();\r\n+                    if (state->currentPlayer == 1) {\r\n+                        u8g2.clearBuffer();\r\n+                        updateDisplay\r\n+                        updateDisplay(\"Red wins!\", 5, 8);\r\n+                    } else {\r\n+                        updateDisplay(\"Yellow wins!\", 5, 8);\r\n+                    }\r\n+                    delay(WIN_DISPLAY_TIME);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    u8g2.clearBuffer();\r\n+                    return;\r\n+                }\r\n+                else if (check_draw(state)) {\r\n+                    // In case of a draw, just clear after a short delay.\r\n+                    FastLED.show();\r\n+                    delay(1000);\r\n+                    state->isActive = false;\r\n+                    FastLED.clear();\r\n+                    FastLED.show();\r\n+                    return;\r\n+                }\r\n+                \r\n+                // Switch players.\r\n+                if (state->currentPlayer == 1) {\r\n+                    u8g2.clearBuffer();\r\n+                    updateDisplay(\"Connect Four\", 0, 10);\r\n+                    updateDisplay(\"Yellow's turn\", 3, 8);\r\n+                } else {\r\n+                    u8g2.clearBuffer();\r\n+                    updateDisplay(\"Connect Four\", 0, 10);\r\n+                    updateDisplay(\"Red's turn\", 3, 8);\r\n+                }\r\n+                \r\n+                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n+                // Pause briefly to debounce input.\r\n+                delay(100);\r\n+                break; // Process one move per update.\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+}\r\n+\r\n+/**\r\n+ * Start the Connect Four game.\r\n+ */\r\n+void connectfour_start(ConnectFourState* state) {\r\n+    connectfour_init(state);\r\n+    // Optional extra delay for debouncing before starting.\r\n+    delay(500);\r\n+    state->isActive = true;\r\n+    while (anyButtonPressed()) {\r\n+        delay(10);\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Check if the Connect Four game is running.\r\n+ */\r\n+bool connectfour_is_running(ConnectFourState* state) {\r\n+    return state->isActive;\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1740907888512,
            "name": "Commit-0",
            "content": "#include \"globals.h\"\r\n#include <string.h>\r\n\r\n#define PLAYER_1_COLOR CRGB::Red\r\n#define PLAYER_2_COLOR CRGB::Blue\r\n#define WIN_COLOR CRGB::Green\r\n#define WIN_DISPLAY_TIME 3000\r\n\r\n// Game state for Connect Four\r\nstruct ConnectFourState {\r\n    int board[6][6];       // 0 = empty, 1 = player1, 2 = player2\r\n    uint8_t currentPlayer; // 1 or 2\r\n    bool isActive;\r\n    unsigned long lastUpdate;\r\n    bool hasWinner;\r\n};\r\n\r\n// Helper: Set the color of a cell at (row, col) on the 6x6 matrix.\r\nvoid setCellColor(int row, int col, CRGB color) {\r\n    // Use the existing function to light the button at that coordinate.\r\n    setButtonColor(row, col, color);\r\n}\r\n\r\n// Initialize the Connect Four board.\r\nvoid connectfour_init(ConnectFourState* state) {\r\n    memset(state->board, 0, sizeof(state->board));\r\n    state->currentPlayer = 1;\r\n    state->isActive = false;\r\n    state->lastUpdate = 0;\r\n    state->hasWinner = false;\r\n    // Optionally clear the display:\r\n    FastLED.clear();\r\n    FastLED.show();\r\n}\r\n\r\n// Check if there are four in a row starting from (row, col) in direction (dRow, dCol)\r\nstatic bool checkDirection(ConnectFourState* state, int row, int col, int dRow, int dCol) {\r\n    int player = state->board[row][col];\r\n    for (int i = 1; i < 4; i++) {\r\n        int newRow = row + i * dRow;\r\n        int newCol = col + i * dCol;\r\n        if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 6 ||\r\n           state->board[newRow][newCol] != player) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Check if the current board has a win.\r\nstatic bool check_win(ConnectFourState* state) {\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            if (state->board[row][col] != 0) {\r\n                // Check horizontally, vertically, and both diagonals.\r\n                if (col <= 6 - 4 && checkDirection(state, row, col, 0, 1))\r\n                    return true;\r\n                if (row <= 6 - 4 && checkDirection(state, row, col, 1, 0))\r\n                    return true;\r\n                if (row <= 6 - 4 && col <= 6 - 4 && checkDirection(state, row, col, 1, 1))\r\n                    return true;\r\n                if (row >= 3 && col <= 6 - 4 && checkDirection(state, row, col, -1, 1))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// Check if the board is full\r\nstatic bool check_draw(ConnectFourState* state) {\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            if (state->board[row][col] == 0) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Helper: Check if any button in the given column is pressed.\r\n// We check all rows in that column. Use your existing checkButton function.\r\nstatic bool columnPressed(int col) {\r\n    for (int row = 0; row < 6; row++) {\r\n        int btnID = ButtonMatrix[row][col];\r\n        if (checkButton(btnID + 1)) {  // Adjust for index if needed.\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Update the Connect Four game state.\r\n * When a button in a column is pressed and the column is not full, a piece is dropped.\r\n */\r\nvoid connectfour_update(ConnectFourState* state) {\r\n    if (!state->isActive) return;\r\n\r\n    FastLED.clear();\r\n\r\n    // Draw the board pieces.\r\n    for (int row = 0; row < 6; row++) {\r\n        for (int col = 0; col < 6; col++) {\r\n            int cell = state->board[row][col];\r\n            if (cell == 1) {\r\n                setCellColor(row, col, PLAYER_1_COLOR);\r\n            }\r\n            else if (cell == 2) {\r\n                setCellColor(row, col, PLAYER_2_COLOR);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check input for each column.\r\n    for (int col = 0; col < 6; col++) {\r\n        if (columnPressed(col)) {\r\n            // Only process one column at a time (debounce).\r\n            // Find the lowest empty cell in this column.\r\n            int dropRow = -1;\r\n            for (int row = 0; row < 6; row++) {\r\n                if (state->board[row][col] == 0) {\r\n                    dropRow = row;\r\n                    break;\r\n                }\r\n            }\r\n            if (dropRow != -1) {\r\n                state->board[dropRow][col] = state->currentPlayer;\r\n                CRGB moveColor = (state->currentPlayer == 1) ? PLAYER_1_COLOR : PLAYER_2_COLOR;\r\n                setCellColor(dropRow, col, moveColor);\r\n                \r\n                // Check for win.\r\n                if (check_win(state)) {\r\n                    state->hasWinner = true;\r\n                    // Highlight winning board (for simplicity, fill entire board with WIN_COLOR).\r\n                    for (int r = 0; r < 6; r++) {\r\n                        for (int c = 0; c < 6; c++) {\r\n                            setCellColor(r, c, WIN_COLOR);\r\n                        }\r\n                    }\r\n                    FastLED.show();\r\n                    delay(WIN_DISPLAY_TIME);\r\n                    state->isActive = false;\r\n                    return;\r\n                }\r\n                else if (check_draw(state)) {\r\n                    // In case of a draw, just clear after a short delay.\r\n                    FastLED.show();\r\n                    delay(1000);\r\n                    state->isActive = false;\r\n                    FastLED.clear();\r\n                    FastLED.show();\r\n                    return;\r\n                }\r\n                \r\n                // Switch players.\r\n                state->currentPlayer = (state->currentPlayer == 1) ? 2 : 1;\r\n                // Pause briefly to debounce input.\r\n                delay(250);\r\n                break; // Process one move per update.\r\n            }\r\n        }\r\n    }\r\n\r\n    FastLED.show();\r\n}\r\n\r\n/**\r\n * Start the Connect Four game.\r\n */\r\nvoid connectfour_start(ConnectFourState* state) {\r\n    connectfour_init(state);\r\n    // Optional extra delay for debouncing before starting.\r\n    delay(500);\r\n    state->isActive = true;\r\n}\r\n\r\n/**\r\n * Check if the Connect Four game is running.\r\n */\r\nbool connectfour_is_running(ConnectFourState* state) {\r\n    return state->isActive;\r\n}"
        }
    ]
}