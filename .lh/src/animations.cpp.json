{
    "sourceFile": "src/animations.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1740852719345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740852755437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,12 +13,12 @@\n     if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n         FastLED.clear();\r\n         // Light up random blocks\r\n         for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, 3);\r\n-            int y = random(0, 3);\r\n+            int x = random(0, 6);\r\n+            int y = random(0, 6);\r\n             CRGB color = CHSV(random(255), 255, 255);\r\n-            setBlockColor(x, y, color);\r\n+            setButtonColor(x, y, color);\r\n         }\r\n         FastLED.show();\r\n         lastRandomBlockUpdate = currentTime;\r\n     }\r\n"
                },
                {
                    "date": 1740852761462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,5 +292,6 @@\n         }\r\n     }\r\n     \r\n     FastLED.show();\r\n-    timeOffset += 2;\n\\ No newline at end of file\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740852767694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,297 @@\n+#include \"globals.h\"\r\n+#include \"animations.h\"\r\n+#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n+#define NUM_BLOCKS 3\r\n+\r\n+static unsigned long lastRandomBlockUpdate = 0;\r\n+\r\n+/**\r\n+ * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n+ */\r\n+void randomBlock() {\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n+        FastLED.clear();\r\n+        // Light up random blocks\r\n+        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n+            int x = random(0, NUM_ROWS);\r\n+            int y = random(0, NUM_COLS);\r\n+            CRGB color = CHSV(random(255), 255, 255);\r\n+            setButtonColor(x, y, color);\r\n+        }\r\n+        FastLED.show();\r\n+        lastRandomBlockUpdate = currentTime;\r\n+    }\r\n+}\r\n+\r\n+#ifdef RAINBOW_SNAKE\r\n+unsigned long lastFoodTime = 0;\r\n+int foodX = -1;\r\n+int foodY = -1;\r\n+const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n+\r\n+/**\r\n+ * Spawns food at a random location on the LED matrix.\r\n+ * Food is represented by a red LED.\r\n+ * @param state The current state of the snake animation.\r\n+ */\r\n+static void spawn_food(SnakeState* state) {\r\n+    do {\r\n+        state->foodX = random(0, 16);\r\n+        state->foodY = random(0, 16);\r\n+    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+}\r\n+\r\n+/**\r\n+ * Initializes the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n+ */\r\n+void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n+    state->x = random(0, 16);\r\n+    state->y = random(0, 16);\r\n+    state->dx = 1;\r\n+    state->dy = 0;\r\n+    state->snakeLength = 8;\r\n+    state->pathIndex = 0;\r\n+    state->lastFoodTime = millis();\r\n+    state->lastUpdate = millis();\r\n+    state->isActive = true;\r\n+    state->wrapAround = wrapAround;\r\n+    FastLED.clear();\r\n+    spawn_food(state);\r\n+}\r\n+\r\n+/**\r\n+ * Updates the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ */\r\n+void snake_update(SnakeState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - state->lastUpdate < 40) return;\r\n+\r\n+    // Spawn food at interval if necessary\r\n+    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    // Check if we need to spawn food after eating\r\n+    bool ateFood = false;\r\n+\r\n+    // Movement logic with collision detection\r\n+    bool moved = false;\r\n+    int directions[6][2];\r\n+    int dirIndex = 0;\r\n+\r\n+    // Weight current direction\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+\r\n+    // Add other directions\r\n+    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n+    for (int k = 0; k < 4; k++) {\r\n+        int pdx = possibleDirections[k][0];\r\n+        int pdy = possibleDirections[k][1];\r\n+        if (pdx != state->dx || pdy != state->dy) {\r\n+            directions[dirIndex][0] = pdx;\r\n+            directions[dirIndex][1] = pdy;\r\n+            dirIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    // Shuffle directions\r\n+    for (int s = 0; s < dirIndex; s++) {\r\n+        int r = random(s, dirIndex);\r\n+        int tempDx = directions[s][0];\r\n+        int tempDy = directions[s][1];\r\n+        directions[s][0] = directions[r][0];\r\n+        directions[s][1] = directions[r][1];\r\n+        directions[r][0] = tempDx;\r\n+        directions[r][1] = tempDy;\r\n+    }\r\n+\r\n+    // Try each direction\r\n+    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n+        int newDx = directions[attempt][0];\r\n+        int newDy = directions[attempt][1];\r\n+        int newX = state->x + newDx;\r\n+        int newY = state->y + newDy;\r\n+\r\n+        if (state->wrapAround) {\r\n+            newX = (newX + LED_COLS) % LED_COLS;\r\n+            newY = (newY + LED_ROWS) % LED_ROWS;\r\n+        } else {\r\n+            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n+                continue;\r\n+            }\r\n+        }\r\n+\r\n+        // Check collision with body\r\n+        bool collision = false;\r\n+        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n+        for (int j = 0; j < checkLength; j++) {\r\n+            int idx = (state->pathIndex - j + 256) % 256;\r\n+            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n+                collision = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!collision) {\r\n+            state->x = newX;\r\n+            state->y = newY;\r\n+            state->dx = newDx;\r\n+            state->dy = newDy;\r\n+            moved = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (!moved) {\r\n+        // Reverse if stuck\r\n+        state->dx = -state->dx;\r\n+        state->dy = -state->dy;\r\n+        state->x += state->dx;\r\n+        state->y += state->dy;\r\n+        // Handle wrap around\r\n+        if (state->wrapAround) {\r\n+            state->x = (state->x + LED_COLS) % LED_COLS;\r\n+            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n+        } else {\r\n+            if (state->x < 0) state->x = 0;\r\n+            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n+            if (state->y < 0) state->y = 0;\r\n+            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // Record position after moving\r\n+    state->path[state->pathIndex][0] = state->x;\r\n+    state->path[state->pathIndex][1] = state->y;\r\n+\r\n+    // Check food collision\r\n+    if (state->x == state->foodX && state->y == state->foodY) {\r\n+        state->snakeLength++;\r\n+        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n+        ateFood = true;\r\n+    }\r\n+\r\n+    // Set current LED with rainbow effect\r\n+    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+\r\n+    // Clear tail\r\n+    if (state->snakeLength < 256) {\r\n+        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n+        int tailX = state->path[tailIndex][0];\r\n+        int tailY = state->path[tailIndex][1];\r\n+        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n+    }\r\n+\r\n+    // Update path index\r\n+    state->pathIndex = (state->pathIndex + 1) % 256;\r\n+\r\n+    // Spawn new food if ate\r\n+    if (ateFood) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+    state->lastUpdate = currentTime;\r\n+}\r\n+#endif\r\n+\r\n+/**\r\n+ * Basic snake animation that follows the Original LED matrix indexing.\r\n+ */\r\n+void rainbow_snake_old() {\r\n+    // light up a rainbow snake of length 8, \r\n+    for (int i = 0; i < NUM_LEDS; i++) {\r\n+        leds[i] = CHSV(i, 255, 255);\r\n+        FastLED.show();\r\n+        delay(10);\r\n+        if (i % 8 == 0) {\r\n+        leds[i] = CRGB::Purple;\r\n+        }\r\n+        // clear leds at i - 8\r\n+        if (i >= 8) {\r\n+        leds[i - 8] = CRGB::Black;\r\n+        } else {\r\n+        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void display_logo() {\r\n+    // Iterate over each byte in the FHMS_LOGO array\r\n+    for (int i = 0; i < 32; i++) {\r\n+        unsigned char byte = FHMS_LOGO[i];\r\n+        // Each byte contains 8 bits\r\n+        for (int bit = 0; bit < 8; bit++) {\r\n+            int bitIndex = i * 8 + bit;\r\n+            int x = bitIndex % 16;\r\n+            int y = bitIndex / 16;\r\n+\r\n+            // Check if the current bit is set\r\n+            if (byte & (0x80 >> bit)) {\r\n+                // Set the LED to white if the bit is 1\r\n+                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+            } else {\r\n+                // Turn off the LED if the bit is 0\r\n+                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n+            }\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+}\r\n+\r\n+void idle_animation() {\r\n+    static uint16_t hueOffset = 0;\r\n+    for (int y = 0; y < 16; y++) {\r\n+        for (int x = 0; x < 16; x++) {\r\n+            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n+            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+    hueOffset += 1;\r\n+}\r\n+\r\n+void wave_ripple_animation() {\r\n+    static uint8_t timeOffset = 0;\r\n+    static const uint8_t numWaves = 3;\r\n+    const uint8_t centerX = 8;\r\n+    const uint8_t centerY = 8;\r\n+    \r\n+    for(int y = 0; y < 16; y++) {\r\n+        for(int x = 0; x < 16; x++) {\r\n+            float distance = sqrt((x - centerX) * (x - centerX) + \r\n+                                (y - centerY) * (y - centerY));\r\n+            \r\n+            uint8_t brightness = 0;\r\n+            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n+                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n+                brightness += sin8(wavePhase) / numWaves;\r\n+            }\r\n+            \r\n+            // Fix: Cast float to int before modulo\r\n+            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n+            \r\n+            if(brightness > 30) {\r\n+                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+            } else {\r\n+                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740852785348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n     if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n         FastLED.clear();\r\n         // Light up random blocks\r\n         for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, NUM_ROWS);\r\n+            int x = random(0, LED_ROWS);\r\n             int y = random(0, NUM_COLS);\r\n             CRGB color = CHSV(random(255), 255, 255);\r\n             setButtonColor(x, y, color);\r\n         }\r\n@@ -293,303 +293,5 @@\n     }\r\n     \r\n     FastLED.show();\r\n     timeOffset += 2;\r\n-}\n-#include \"globals.h\"\r\n-#include \"animations.h\"\r\n-#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 3\r\n-\r\n-static unsigned long lastRandomBlockUpdate = 0;\r\n-\r\n-/**\r\n- * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n- */\r\n-void randomBlock() {\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n-        FastLED.clear();\r\n-        // Light up random blocks\r\n-        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, 6);\r\n-            int y = random(0, 6);\r\n-            CRGB color = CHSV(random(255), 255, 255);\r\n-            setButtonColor(x, y, color);\r\n-        }\r\n-        FastLED.show();\r\n-        lastRandomBlockUpdate = currentTime;\r\n-    }\r\n-}\r\n-\r\n-#ifdef RAINBOW_SNAKE\r\n-unsigned long lastFoodTime = 0;\r\n-int foodX = -1;\r\n-int foodY = -1;\r\n-const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n-\r\n-/**\r\n- * Spawns food at a random location on the LED matrix.\r\n- * Food is represented by a red LED.\r\n- * @param state The current state of the snake animation.\r\n- */\r\n-static void spawn_food(SnakeState* state) {\r\n-    do {\r\n-        state->foodX = random(0, 16);\r\n-        state->foodY = random(0, 16);\r\n-    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n-    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n-}\r\n-\r\n-/**\r\n- * Initializes the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n- */\r\n-void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n-    state->x = random(0, 16);\r\n-    state->y = random(0, 16);\r\n-    state->dx = 1;\r\n-    state->dy = 0;\r\n-    state->snakeLength = 8;\r\n-    state->pathIndex = 0;\r\n-    state->lastFoodTime = millis();\r\n-    state->lastUpdate = millis();\r\n-    state->isActive = true;\r\n-    state->wrapAround = wrapAround;\r\n-    FastLED.clear();\r\n-    spawn_food(state);\r\n-}\r\n-\r\n-/**\r\n- * Updates the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- */\r\n-void snake_update(SnakeState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - state->lastUpdate < 40) return;\r\n-\r\n-    // Spawn food at interval if necessary\r\n-    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    // Check if we need to spawn food after eating\r\n-    bool ateFood = false;\r\n-\r\n-    // Movement logic with collision detection\r\n-    bool moved = false;\r\n-    int directions[6][2];\r\n-    int dirIndex = 0;\r\n-\r\n-    // Weight current direction\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-\r\n-    // Add other directions\r\n-    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n-    for (int k = 0; k < 4; k++) {\r\n-        int pdx = possibleDirections[k][0];\r\n-        int pdy = possibleDirections[k][1];\r\n-        if (pdx != state->dx || pdy != state->dy) {\r\n-            directions[dirIndex][0] = pdx;\r\n-            directions[dirIndex][1] = pdy;\r\n-            dirIndex++;\r\n-        }\r\n-    }\r\n-\r\n-    // Shuffle directions\r\n-    for (int s = 0; s < dirIndex; s++) {\r\n-        int r = random(s, dirIndex);\r\n-        int tempDx = directions[s][0];\r\n-        int tempDy = directions[s][1];\r\n-        directions[s][0] = directions[r][0];\r\n-        directions[s][1] = directions[r][1];\r\n-        directions[r][0] = tempDx;\r\n-        directions[r][1] = tempDy;\r\n-    }\r\n-\r\n-    // Try each direction\r\n-    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n-        int newDx = directions[attempt][0];\r\n-        int newDy = directions[attempt][1];\r\n-        int newX = state->x + newDx;\r\n-        int newY = state->y + newDy;\r\n-\r\n-        if (state->wrapAround) {\r\n-            newX = (newX + LED_COLS) % LED_COLS;\r\n-            newY = (newY + LED_ROWS) % LED_ROWS;\r\n-        } else {\r\n-            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n-                continue;\r\n-            }\r\n-        }\r\n-\r\n-        // Check collision with body\r\n-        bool collision = false;\r\n-        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n-        for (int j = 0; j < checkLength; j++) {\r\n-            int idx = (state->pathIndex - j + 256) % 256;\r\n-            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n-                collision = true;\r\n-                break;\r\n-            }\r\n-        }\r\n-\r\n-        if (!collision) {\r\n-            state->x = newX;\r\n-            state->y = newY;\r\n-            state->dx = newDx;\r\n-            state->dy = newDy;\r\n-            moved = true;\r\n-        }\r\n-    }\r\n-\r\n-    if (!moved) {\r\n-        // Reverse if stuck\r\n-        state->dx = -state->dx;\r\n-        state->dy = -state->dy;\r\n-        state->x += state->dx;\r\n-        state->y += state->dy;\r\n-        // Handle wrap around\r\n-        if (state->wrapAround) {\r\n-            state->x = (state->x + LED_COLS) % LED_COLS;\r\n-            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n-        } else {\r\n-            if (state->x < 0) state->x = 0;\r\n-            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n-            if (state->y < 0) state->y = 0;\r\n-            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n-        }\r\n-    }\r\n-\r\n-    // Record position after moving\r\n-    state->path[state->pathIndex][0] = state->x;\r\n-    state->path[state->pathIndex][1] = state->y;\r\n-\r\n-    // Check food collision\r\n-    if (state->x == state->foodX && state->y == state->foodY) {\r\n-        state->snakeLength++;\r\n-        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n-        ateFood = true;\r\n-    }\r\n-\r\n-    // Set current LED with rainbow effect\r\n-    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n-\r\n-    // Clear tail\r\n-    if (state->snakeLength < 256) {\r\n-        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n-        int tailX = state->path[tailIndex][0];\r\n-        int tailY = state->path[tailIndex][1];\r\n-        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n-    }\r\n-\r\n-    // Update path index\r\n-    state->pathIndex = (state->pathIndex + 1) % 256;\r\n-\r\n-    // Spawn new food if ate\r\n-    if (ateFood) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-    state->lastUpdate = currentTime;\r\n-}\r\n-#endif\r\n-\r\n-/**\r\n- * Basic snake animation that follows the Original LED matrix indexing.\r\n- */\r\n-void rainbow_snake_old() {\r\n-    // light up a rainbow snake of length 8, \r\n-    for (int i = 0; i < NUM_LEDS; i++) {\r\n-        leds[i] = CHSV(i, 255, 255);\r\n-        FastLED.show();\r\n-        delay(10);\r\n-        if (i % 8 == 0) {\r\n-        leds[i] = CRGB::Purple;\r\n-        }\r\n-        // clear leds at i - 8\r\n-        if (i >= 8) {\r\n-        leds[i - 8] = CRGB::Black;\r\n-        } else {\r\n-        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void display_logo() {\r\n-    // Iterate over each byte in the FHMS_LOGO array\r\n-    for (int i = 0; i < 32; i++) {\r\n-        unsigned char byte = FHMS_LOGO[i];\r\n-        // Each byte contains 8 bits\r\n-        for (int bit = 0; bit < 8; bit++) {\r\n-            int bitIndex = i * 8 + bit;\r\n-            int x = bitIndex % 16;\r\n-            int y = bitIndex / 16;\r\n-\r\n-            // Check if the current bit is set\r\n-            if (byte & (0x80 >> bit)) {\r\n-                // Set the LED to white if the bit is 1\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n-            } else {\r\n-                // Turn off the LED if the bit is 0\r\n-                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n-            }\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-}\r\n-\r\n-void idle_animation() {\r\n-    static uint16_t hueOffset = 0;\r\n-    for (int y = 0; y < 16; y++) {\r\n-        for (int x = 0; x < 16; x++) {\r\n-            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n-            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-    hueOffset += 1;\r\n-}\r\n-\r\n-void wave_ripple_animation() {\r\n-    static uint8_t timeOffset = 0;\r\n-    static const uint8_t numWaves = 3;\r\n-    const uint8_t centerX = 8;\r\n-    const uint8_t centerY = 8;\r\n-    \r\n-    for(int y = 0; y < 16; y++) {\r\n-        for(int x = 0; x < 16; x++) {\r\n-            float distance = sqrt((x - centerX) * (x - centerX) + \r\n-                                (y - centerY) * (y - centerY));\r\n-            \r\n-            uint8_t brightness = 0;\r\n-            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n-                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n-                brightness += sin8(wavePhase) / numWaves;\r\n-            }\r\n-            \r\n-            // Fix: Cast float to int before modulo\r\n-            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n-            \r\n-            if(brightness > 30) {\r\n-                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n-            } else {\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    FastLED.show();\r\n-    timeOffset += 2;\r\n-}\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740852791516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,297 @@\n+#include \"globals.h\"\r\n+#include \"animations.h\"\r\n+#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n+#define NUM_BLOCKS 3\r\n+\r\n+static unsigned long lastRandomBlockUpdate = 0;\r\n+\r\n+/**\r\n+ * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n+ */\r\n+void randomBlock() {\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n+        FastLED.clear();\r\n+        // Light up random blocks\r\n+        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n+            int x = random(0, LED_ROWS);\r\n+            int y = random(0, LED_COLS);\r\n+            CRGB color = CHSV(random(255), 255, 255);\r\n+            setButtonColor(x, y, color);\r\n+        }\r\n+        FastLED.show();\r\n+        lastRandomBlockUpdate = currentTime;\r\n+    }\r\n+}\r\n+\r\n+#ifdef RAINBOW_SNAKE\r\n+unsigned long lastFoodTime = 0;\r\n+int foodX = -1;\r\n+int foodY = -1;\r\n+const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n+\r\n+/**\r\n+ * Spawns food at a random location on the LED matrix.\r\n+ * Food is represented by a red LED.\r\n+ * @param state The current state of the snake animation.\r\n+ */\r\n+static void spawn_food(SnakeState* state) {\r\n+    do {\r\n+        state->foodX = random(0, 16);\r\n+        state->foodY = random(0, 16);\r\n+    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+}\r\n+\r\n+/**\r\n+ * Initializes the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n+ */\r\n+void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n+    state->x = random(0, 16);\r\n+    state->y = random(0, 16);\r\n+    state->dx = 1;\r\n+    state->dy = 0;\r\n+    state->snakeLength = 8;\r\n+    state->pathIndex = 0;\r\n+    state->lastFoodTime = millis();\r\n+    state->lastUpdate = millis();\r\n+    state->isActive = true;\r\n+    state->wrapAround = wrapAround;\r\n+    FastLED.clear();\r\n+    spawn_food(state);\r\n+}\r\n+\r\n+/**\r\n+ * Updates the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ */\r\n+void snake_update(SnakeState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - state->lastUpdate < 40) return;\r\n+\r\n+    // Spawn food at interval if necessary\r\n+    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    // Check if we need to spawn food after eating\r\n+    bool ateFood = false;\r\n+\r\n+    // Movement logic with collision detection\r\n+    bool moved = false;\r\n+    int directions[6][2];\r\n+    int dirIndex = 0;\r\n+\r\n+    // Weight current direction\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+\r\n+    // Add other directions\r\n+    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n+    for (int k = 0; k < 4; k++) {\r\n+        int pdx = possibleDirections[k][0];\r\n+        int pdy = possibleDirections[k][1];\r\n+        if (pdx != state->dx || pdy != state->dy) {\r\n+            directions[dirIndex][0] = pdx;\r\n+            directions[dirIndex][1] = pdy;\r\n+            dirIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    // Shuffle directions\r\n+    for (int s = 0; s < dirIndex; s++) {\r\n+        int r = random(s, dirIndex);\r\n+        int tempDx = directions[s][0];\r\n+        int tempDy = directions[s][1];\r\n+        directions[s][0] = directions[r][0];\r\n+        directions[s][1] = directions[r][1];\r\n+        directions[r][0] = tempDx;\r\n+        directions[r][1] = tempDy;\r\n+    }\r\n+\r\n+    // Try each direction\r\n+    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n+        int newDx = directions[attempt][0];\r\n+        int newDy = directions[attempt][1];\r\n+        int newX = state->x + newDx;\r\n+        int newY = state->y + newDy;\r\n+\r\n+        if (state->wrapAround) {\r\n+            newX = (newX + LED_COLS) % LED_COLS;\r\n+            newY = (newY + LED_ROWS) % LED_ROWS;\r\n+        } else {\r\n+            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n+                continue;\r\n+            }\r\n+        }\r\n+\r\n+        // Check collision with body\r\n+        bool collision = false;\r\n+        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n+        for (int j = 0; j < checkLength; j++) {\r\n+            int idx = (state->pathIndex - j + 256) % 256;\r\n+            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n+                collision = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!collision) {\r\n+            state->x = newX;\r\n+            state->y = newY;\r\n+            state->dx = newDx;\r\n+            state->dy = newDy;\r\n+            moved = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (!moved) {\r\n+        // Reverse if stuck\r\n+        state->dx = -state->dx;\r\n+        state->dy = -state->dy;\r\n+        state->x += state->dx;\r\n+        state->y += state->dy;\r\n+        // Handle wrap around\r\n+        if (state->wrapAround) {\r\n+            state->x = (state->x + LED_COLS) % LED_COLS;\r\n+            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n+        } else {\r\n+            if (state->x < 0) state->x = 0;\r\n+            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n+            if (state->y < 0) state->y = 0;\r\n+            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // Record position after moving\r\n+    state->path[state->pathIndex][0] = state->x;\r\n+    state->path[state->pathIndex][1] = state->y;\r\n+\r\n+    // Check food collision\r\n+    if (state->x == state->foodX && state->y == state->foodY) {\r\n+        state->snakeLength++;\r\n+        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n+        ateFood = true;\r\n+    }\r\n+\r\n+    // Set current LED with rainbow effect\r\n+    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+\r\n+    // Clear tail\r\n+    if (state->snakeLength < 256) {\r\n+        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n+        int tailX = state->path[tailIndex][0];\r\n+        int tailY = state->path[tailIndex][1];\r\n+        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n+    }\r\n+\r\n+    // Update path index\r\n+    state->pathIndex = (state->pathIndex + 1) % 256;\r\n+\r\n+    // Spawn new food if ate\r\n+    if (ateFood) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+    state->lastUpdate = currentTime;\r\n+}\r\n+#endif\r\n+\r\n+/**\r\n+ * Basic snake animation that follows the Original LED matrix indexing.\r\n+ */\r\n+void rainbow_snake_old() {\r\n+    // light up a rainbow snake of length 8, \r\n+    for (int i = 0; i < NUM_LEDS; i++) {\r\n+        leds[i] = CHSV(i, 255, 255);\r\n+        FastLED.show();\r\n+        delay(10);\r\n+        if (i % 8 == 0) {\r\n+        leds[i] = CRGB::Purple;\r\n+        }\r\n+        // clear leds at i - 8\r\n+        if (i >= 8) {\r\n+        leds[i - 8] = CRGB::Black;\r\n+        } else {\r\n+        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void display_logo() {\r\n+    // Iterate over each byte in the FHMS_LOGO array\r\n+    for (int i = 0; i < 32; i++) {\r\n+        unsigned char byte = FHMS_LOGO[i];\r\n+        // Each byte contains 8 bits\r\n+        for (int bit = 0; bit < 8; bit++) {\r\n+            int bitIndex = i * 8 + bit;\r\n+            int x = bitIndex % 16;\r\n+            int y = bitIndex / 16;\r\n+\r\n+            // Check if the current bit is set\r\n+            if (byte & (0x80 >> bit)) {\r\n+                // Set the LED to white if the bit is 1\r\n+                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+            } else {\r\n+                // Turn off the LED if the bit is 0\r\n+                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n+            }\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+}\r\n+\r\n+void idle_animation() {\r\n+    static uint16_t hueOffset = 0;\r\n+    for (int y = 0; y < 16; y++) {\r\n+        for (int x = 0; x < 16; x++) {\r\n+            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n+            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+    hueOffset += 1;\r\n+}\r\n+\r\n+void wave_ripple_animation() {\r\n+    static uint8_t timeOffset = 0;\r\n+    static const uint8_t numWaves = 3;\r\n+    const uint8_t centerX = 8;\r\n+    const uint8_t centerY = 8;\r\n+    \r\n+    for(int y = 0; y < 16; y++) {\r\n+        for(int x = 0; x < 16; x++) {\r\n+            float distance = sqrt((x - centerX) * (x - centerX) + \r\n+                                (y - centerY) * (y - centerY));\r\n+            \r\n+            uint8_t brightness = 0;\r\n+            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n+                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n+                brightness += sin8(wavePhase) / numWaves;\r\n+            }\r\n+            \r\n+            // Fix: Cast float to int before modulo\r\n+            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n+            \r\n+            if(brightness > 30) {\r\n+                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+            } else {\r\n+                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740854738337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,10 +38,10 @@\n static void spawn_food(SnakeState* state) {\r\n     do {\r\n         state->foodX = random(0, 16);\r\n         state->foodY = random(0, 16);\r\n-    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n-    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n }\r\n \r\n /**\r\n  * Initializes the snake animation with the given state.\r\n@@ -183,16 +183,16 @@\n         ateFood = true;\r\n     }\r\n \r\n     // Set current LED with rainbow effect\r\n-    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n \r\n     // Clear tail\r\n     if (state->snakeLength < 256) {\r\n         int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n         int tailX = state->path[tailIndex][0];\r\n         int tailY = state->path[tailIndex][1];\r\n-        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n+        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n     }\r\n \r\n     // Update path index\r\n     state->pathIndex = (state->pathIndex + 1) % 256;\r\n@@ -241,12 +241,12 @@\n \r\n             // Check if the current bit is set\r\n             if (byte & (0x80 >> bit)) {\r\n                 // Set the LED to white if the bit is 1\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n             } else {\r\n                 // Turn off the LED if the bit is 0\r\n-                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n             }\r\n         }\r\n     }\r\n     FastLED.show();\r\n@@ -256,9 +256,9 @@\n     static uint16_t hueOffset = 0;\r\n     for (int y = 0; y < 16; y++) {\r\n         for (int x = 0; x < 16; x++) {\r\n             uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n-            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n         }\r\n     }\r\n     FastLED.show();\r\n     hueOffset += 1;\r\n@@ -284,11 +284,11 @@\n             // Fix: Cast float to int before modulo\r\n             uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n             \r\n             if(brightness > 30) {\r\n-                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n             } else {\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n             }\r\n         }\r\n     }\r\n     \r\n"
                },
                {
                    "date": 1740855355447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n     if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n         FastLED.clear();\r\n         // Light up random blocks\r\n         for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, LED_ROWS);\r\n+            int x = random(0, BUTTON_ROWS);\r\n             int y = random(0, LED_COLS);\r\n             CRGB color = CHSV(random(255), 255, 255);\r\n             setButtonColor(x, y, color);\r\n         }\r\n@@ -126,11 +126,11 @@\n         int newY = state->y + newDy;\r\n \r\n         if (state->wrapAround) {\r\n             newX = (newX + LED_COLS) % LED_COLS;\r\n-            newY = (newY + LED_ROWS) % LED_ROWS;\r\n+            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n         } else {\r\n-            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n+            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n                 continue;\r\n             }\r\n         }\r\n \r\n@@ -162,14 +162,14 @@\n         state->y += state->dy;\r\n         // Handle wrap around\r\n         if (state->wrapAround) {\r\n             state->x = (state->x + LED_COLS) % LED_COLS;\r\n-            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n+            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n         } else {\r\n             if (state->x < 0) state->x = 0;\r\n             if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n             if (state->y < 0) state->y = 0;\r\n-            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n+            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n         }\r\n     }\r\n \r\n     // Record position after moving\r\n"
                },
                {
                    "date": 1740855384905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n         FastLED.clear();\r\n         // Light up random blocks\r\n         for (int i = 0; i < NUM_BLOCKS; i++) {\r\n             int x = random(0, BUTTON_ROWS);\r\n-            int y = random(0, LED_COLS);\r\n+            int y = random(0, BUTTON_COLS);\r\n             CRGB color = CHSV(random(255), 255, 255);\r\n             setButtonColor(x, y, color);\r\n         }\r\n         FastLED.show();\r\n@@ -125,12 +125,12 @@\n         int newX = state->x + newDx;\r\n         int newY = state->y + newDy;\r\n \r\n         if (state->wrapAround) {\r\n-            newX = (newX + LED_COLS) % LED_COLS;\r\n+            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n             newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n         } else {\r\n-            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n+            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n                 continue;\r\n             }\r\n         }\r\n \r\n@@ -161,13 +161,13 @@\n         state->x += state->dx;\r\n         state->y += state->dy;\r\n         // Handle wrap around\r\n         if (state->wrapAround) {\r\n-            state->x = (state->x + LED_COLS) % LED_COLS;\r\n+            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n             state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n         } else {\r\n             if (state->x < 0) state->x = 0;\r\n-            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n+            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n             if (state->y < 0) state->y = 0;\r\n             if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n         }\r\n     }\r\n@@ -293,302 +293,5 @@\n     }\r\n     \r\n     FastLED.show();\r\n     timeOffset += 2;\r\n-}\n-#include \"globals.h\"\r\n-#include \"animations.h\"\r\n-#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 3\r\n-\r\n-static unsigned long lastRandomBlockUpdate = 0;\r\n-\r\n-/**\r\n- * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n- */\r\n-void randomBlock() {\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n-        FastLED.clear();\r\n-        // Light up random blocks\r\n-        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, LED_ROWS);\r\n-            int y = random(0, NUM_COLS);\r\n-            CRGB color = CHSV(random(255), 255, 255);\r\n-            setButtonColor(x, y, color);\r\n-        }\r\n-        FastLED.show();\r\n-        lastRandomBlockUpdate = currentTime;\r\n-    }\r\n-}\r\n-\r\n-#ifdef RAINBOW_SNAKE\r\n-unsigned long lastFoodTime = 0;\r\n-int foodX = -1;\r\n-int foodY = -1;\r\n-const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n-\r\n-/**\r\n- * Spawns food at a random location on the LED matrix.\r\n- * Food is represented by a red LED.\r\n- * @param state The current state of the snake animation.\r\n- */\r\n-static void spawn_food(SnakeState* state) {\r\n-    do {\r\n-        state->foodX = random(0, 16);\r\n-        state->foodY = random(0, 16);\r\n-    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n-    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n-}\r\n-\r\n-/**\r\n- * Initializes the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n- */\r\n-void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n-    state->x = random(0, 16);\r\n-    state->y = random(0, 16);\r\n-    state->dx = 1;\r\n-    state->dy = 0;\r\n-    state->snakeLength = 8;\r\n-    state->pathIndex = 0;\r\n-    state->lastFoodTime = millis();\r\n-    state->lastUpdate = millis();\r\n-    state->isActive = true;\r\n-    state->wrapAround = wrapAround;\r\n-    FastLED.clear();\r\n-    spawn_food(state);\r\n-}\r\n-\r\n-/**\r\n- * Updates the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- */\r\n-void snake_update(SnakeState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - state->lastUpdate < 40) return;\r\n-\r\n-    // Spawn food at interval if necessary\r\n-    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    // Check if we need to spawn food after eating\r\n-    bool ateFood = false;\r\n-\r\n-    // Movement logic with collision detection\r\n-    bool moved = false;\r\n-    int directions[6][2];\r\n-    int dirIndex = 0;\r\n-\r\n-    // Weight current direction\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-\r\n-    // Add other directions\r\n-    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n-    for (int k = 0; k < 4; k++) {\r\n-        int pdx = possibleDirections[k][0];\r\n-        int pdy = possibleDirections[k][1];\r\n-        if (pdx != state->dx || pdy != state->dy) {\r\n-            directions[dirIndex][0] = pdx;\r\n-            directions[dirIndex][1] = pdy;\r\n-            dirIndex++;\r\n-        }\r\n-    }\r\n-\r\n-    // Shuffle directions\r\n-    for (int s = 0; s < dirIndex; s++) {\r\n-        int r = random(s, dirIndex);\r\n-        int tempDx = directions[s][0];\r\n-        int tempDy = directions[s][1];\r\n-        directions[s][0] = directions[r][0];\r\n-        directions[s][1] = directions[r][1];\r\n-        directions[r][0] = tempDx;\r\n-        directions[r][1] = tempDy;\r\n-    }\r\n-\r\n-    // Try each direction\r\n-    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n-        int newDx = directions[attempt][0];\r\n-        int newDy = directions[attempt][1];\r\n-        int newX = state->x + newDx;\r\n-        int newY = state->y + newDy;\r\n-\r\n-        if (state->wrapAround) {\r\n-            newX = (newX + LED_COLS) % LED_COLS;\r\n-            newY = (newY + LED_ROWS) % LED_ROWS;\r\n-        } else {\r\n-            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n-                continue;\r\n-            }\r\n-        }\r\n-\r\n-        // Check collision with body\r\n-        bool collision = false;\r\n-        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n-        for (int j = 0; j < checkLength; j++) {\r\n-            int idx = (state->pathIndex - j + 256) % 256;\r\n-            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n-                collision = true;\r\n-                break;\r\n-            }\r\n-        }\r\n-\r\n-        if (!collision) {\r\n-            state->x = newX;\r\n-            state->y = newY;\r\n-            state->dx = newDx;\r\n-            state->dy = newDy;\r\n-            moved = true;\r\n-        }\r\n-    }\r\n-\r\n-    if (!moved) {\r\n-        // Reverse if stuck\r\n-        state->dx = -state->dx;\r\n-        state->dy = -state->dy;\r\n-        state->x += state->dx;\r\n-        state->y += state->dy;\r\n-        // Handle wrap around\r\n-        if (state->wrapAround) {\r\n-            state->x = (state->x + LED_COLS) % LED_COLS;\r\n-            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n-        } else {\r\n-            if (state->x < 0) state->x = 0;\r\n-            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n-            if (state->y < 0) state->y = 0;\r\n-            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n-        }\r\n-    }\r\n-\r\n-    // Record position after moving\r\n-    state->path[state->pathIndex][0] = state->x;\r\n-    state->path[state->pathIndex][1] = state->y;\r\n-\r\n-    // Check food collision\r\n-    if (state->x == state->foodX && state->y == state->foodY) {\r\n-        state->snakeLength++;\r\n-        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n-        ateFood = true;\r\n-    }\r\n-\r\n-    // Set current LED with rainbow effect\r\n-    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n-\r\n-    // Clear tail\r\n-    if (state->snakeLength < 256) {\r\n-        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n-        int tailX = state->path[tailIndex][0];\r\n-        int tailY = state->path[tailIndex][1];\r\n-        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n-    }\r\n-\r\n-    // Update path index\r\n-    state->pathIndex = (state->pathIndex + 1) % 256;\r\n-\r\n-    // Spawn new food if ate\r\n-    if (ateFood) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-    state->lastUpdate = currentTime;\r\n-}\r\n-#endif\r\n-\r\n-/**\r\n- * Basic snake animation that follows the Original LED matrix indexing.\r\n- */\r\n-void rainbow_snake_old() {\r\n-    // light up a rainbow snake of length 8, \r\n-    for (int i = 0; i < NUM_LEDS; i++) {\r\n-        leds[i] = CHSV(i, 255, 255);\r\n-        FastLED.show();\r\n-        delay(10);\r\n-        if (i % 8 == 0) {\r\n-        leds[i] = CRGB::Purple;\r\n-        }\r\n-        // clear leds at i - 8\r\n-        if (i >= 8) {\r\n-        leds[i - 8] = CRGB::Black;\r\n-        } else {\r\n-        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void display_logo() {\r\n-    // Iterate over each byte in the FHMS_LOGO array\r\n-    for (int i = 0; i < 32; i++) {\r\n-        unsigned char byte = FHMS_LOGO[i];\r\n-        // Each byte contains 8 bits\r\n-        for (int bit = 0; bit < 8; bit++) {\r\n-            int bitIndex = i * 8 + bit;\r\n-            int x = bitIndex % 16;\r\n-            int y = bitIndex / 16;\r\n-\r\n-            // Check if the current bit is set\r\n-            if (byte & (0x80 >> bit)) {\r\n-                // Set the LED to white if the bit is 1\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n-            } else {\r\n-                // Turn off the LED if the bit is 0\r\n-                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n-            }\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-}\r\n-\r\n-void idle_animation() {\r\n-    static uint16_t hueOffset = 0;\r\n-    for (int y = 0; y < 16; y++) {\r\n-        for (int x = 0; x < 16; x++) {\r\n-            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n-            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-    hueOffset += 1;\r\n-}\r\n-\r\n-void wave_ripple_animation() {\r\n-    static uint8_t timeOffset = 0;\r\n-    static const uint8_t numWaves = 3;\r\n-    const uint8_t centerX = 8;\r\n-    const uint8_t centerY = 8;\r\n-    \r\n-    for(int y = 0; y < 16; y++) {\r\n-        for(int x = 0; x < 16; x++) {\r\n-            float distance = sqrt((x - centerX) * (x - centerX) + \r\n-                                (y - centerY) * (y - centerY));\r\n-            \r\n-            uint8_t brightness = 0;\r\n-            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n-                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n-                brightness += sin8(wavePhase) / numWaves;\r\n-            }\r\n-            \r\n-            // Fix: Cast float to int before modulo\r\n-            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n-            \r\n-            if(brightness > 30) {\r\n-                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n-            } else {\r\n-                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    FastLED.show();\r\n-    timeOffset += 2;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740855725295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n #include \"globals.h\"\r\n #include \"animations.h\"\r\n #define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 3\r\n+#define NUM_BLOCKS 6\r\n \r\n static unsigned long lastRandomBlockUpdate = 0;\r\n \r\n /**\r\n"
                },
                {
                    "date": 1740855744890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n #include \"globals.h\"\r\n #include \"animations.h\"\r\n #define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 6\r\n+#define NUM_BLOCKS 3\r\n \r\n static unsigned long lastRandomBlockUpdate = 0;\r\n \r\n /**\r\n"
                },
                {
                    "date": 1740855767463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,297 @@\n+#include \"globals.h\"\r\n+#include \"animations.h\"\r\n+#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n+#define NUM_BLOCKS 3\r\n+\r\n+static unsigned long lastRandomBlockUpdate = 0;\r\n+\r\n+/**\r\n+ * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n+ */\r\n+void randomBlock() {\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n+        FastLED.clear();\r\n+        // Light up random blocks\r\n+        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n+            int x = random(0, BUTTON_ROWS);\r\n+            int y = random(0, BUTTON_COLS);\r\n+            CRGB color = CHSV(random(255), 255, 255);\r\n+            setButtonColor(x, y, color);\r\n+        }\r\n+        FastLED.show();\r\n+        lastRandomBlockUpdate = currentTime;\r\n+    }\r\n+}\r\n+\r\n+#ifdef RAINBOW_SNAKE\r\n+unsigned long lastFoodTime = 0;\r\n+int foodX = -1;\r\n+int foodY = -1;\r\n+const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n+\r\n+/**\r\n+ * Spawns food at a random location on the LED matrix.\r\n+ * Food is represented by a red LED.\r\n+ * @param state The current state of the snake animation.\r\n+ */\r\n+static void spawn_food(SnakeState* state) {\r\n+    do {\r\n+        state->foodX = random(0, 16);\r\n+        state->foodY = random(0, 16);\r\n+    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+}\r\n+\r\n+/**\r\n+ * Initializes the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n+ */\r\n+void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n+    state->x = random(0, 16);\r\n+    state->y = random(0, 16);\r\n+    state->dx = 1;\r\n+    state->dy = 0;\r\n+    state->snakeLength = 8;\r\n+    state->pathIndex = 0;\r\n+    state->lastFoodTime = millis();\r\n+    state->lastUpdate = millis();\r\n+    state->isActive = true;\r\n+    state->wrapAround = wrapAround;\r\n+    FastLED.clear();\r\n+    spawn_food(state);\r\n+}\r\n+\r\n+/**\r\n+ * Updates the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ */\r\n+void snake_update(SnakeState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - state->lastUpdate < 40) return;\r\n+\r\n+    // Spawn food at interval if necessary\r\n+    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    // Check if we need to spawn food after eating\r\n+    bool ateFood = false;\r\n+\r\n+    // Movement logic with collision detection\r\n+    bool moved = false;\r\n+    int directions[6][2];\r\n+    int dirIndex = 0;\r\n+\r\n+    // Weight current direction\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+\r\n+    // Add other directions\r\n+    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n+    for (int k = 0; k < 4; k++) {\r\n+        int pdx = possibleDirections[k][0];\r\n+        int pdy = possibleDirections[k][1];\r\n+        if (pdx != state->dx || pdy != state->dy) {\r\n+            directions[dirIndex][0] = pdx;\r\n+            directions[dirIndex][1] = pdy;\r\n+            dirIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    // Shuffle directions\r\n+    for (int s = 0; s < dirIndex; s++) {\r\n+        int r = random(s, dirIndex);\r\n+        int tempDx = directions[s][0];\r\n+        int tempDy = directions[s][1];\r\n+        directions[s][0] = directions[r][0];\r\n+        directions[s][1] = directions[r][1];\r\n+        directions[r][0] = tempDx;\r\n+        directions[r][1] = tempDy;\r\n+    }\r\n+\r\n+    // Try each direction\r\n+    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n+        int newDx = directions[attempt][0];\r\n+        int newDy = directions[attempt][1];\r\n+        int newX = state->x + newDx;\r\n+        int newY = state->y + newDy;\r\n+\r\n+        if (state->wrapAround) {\r\n+            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n+            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n+                continue;\r\n+            }\r\n+        }\r\n+\r\n+        // Check collision with body\r\n+        bool collision = false;\r\n+        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n+        for (int j = 0; j < checkLength; j++) {\r\n+            int idx = (state->pathIndex - j + 256) % 256;\r\n+            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n+                collision = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!collision) {\r\n+            state->x = newX;\r\n+            state->y = newY;\r\n+            state->dx = newDx;\r\n+            state->dy = newDy;\r\n+            moved = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (!moved) {\r\n+        // Reverse if stuck\r\n+        state->dx = -state->dx;\r\n+        state->dy = -state->dy;\r\n+        state->x += state->dx;\r\n+        state->y += state->dy;\r\n+        // Handle wrap around\r\n+        if (state->wrapAround) {\r\n+            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n+            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (state->x < 0) state->x = 0;\r\n+            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n+            if (state->y < 0) state->y = 0;\r\n+            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // Record position after moving\r\n+    state->path[state->pathIndex][0] = state->x;\r\n+    state->path[state->pathIndex][1] = state->y;\r\n+\r\n+    // Check food collision\r\n+    if (state->x == state->foodX && state->y == state->foodY) {\r\n+        state->snakeLength++;\r\n+        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n+        ateFood = true;\r\n+    }\r\n+\r\n+    // Set current LED with rainbow effect\r\n+    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+\r\n+    // Clear tail\r\n+    if (state->snakeLength < 256) {\r\n+        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n+        int tailX = state->path[tailIndex][0];\r\n+        int tailY = state->path[tailIndex][1];\r\n+        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n+    }\r\n+\r\n+    // Update path index\r\n+    state->pathIndex = (state->pathIndex + 1) % 256;\r\n+\r\n+    // Spawn new food if ate\r\n+    if (ateFood) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+    state->lastUpdate = currentTime;\r\n+}\r\n+#endif\r\n+\r\n+/**\r\n+ * Basic snake animation that follows the Original LED matrix indexing.\r\n+ */\r\n+void rainbow_snake_old() {\r\n+    // light up a rainbow snake of length 8, \r\n+    for (int i = 0; i < NUM_LEDS; i++) {\r\n+        leds[i] = CHSV(i, 255, 255);\r\n+        FastLED.show();\r\n+        delay(10);\r\n+        if (i % 8 == 0) {\r\n+        leds[i] = CRGB::Purple;\r\n+        }\r\n+        // clear leds at i - 8\r\n+        if (i >= 8) {\r\n+        leds[i - 8] = CRGB::Black;\r\n+        } else {\r\n+        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void display_logo() {\r\n+    // Iterate over each byte in the FHMS_LOGO array\r\n+    for (int i = 0; i < 32; i++) {\r\n+        unsigned char byte = FHMS_LOGO[i];\r\n+        // Each byte contains 8 bits\r\n+        for (int bit = 0; bit < 8; bit++) {\r\n+            int bitIndex = i * 8 + bit;\r\n+            int x = bitIndex % 16;\r\n+            int y = bitIndex / 16;\r\n+\r\n+            // Check if the current bit is set\r\n+            if (byte & (0x80 >> bit)) {\r\n+                // Set the LED to white if the bit is 1\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n+            } else {\r\n+                // Turn off the LED if the bit is 0\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n+            }\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+}\r\n+\r\n+void idle_animation() {\r\n+    static uint16_t hueOffset = 0;\r\n+    for (int y = 0; y < 6; y++) {\r\n+        for (int x = 0; x < 16; x++) {\r\n+            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n+            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+    hueOffset += 1;\r\n+}\r\n+\r\n+void wave_ripple_animation() {\r\n+    static uint8_t timeOffset = 0;\r\n+    static const uint8_t numWaves = 3;\r\n+    const uint8_t centerX = 8;\r\n+    const uint8_t centerY = 8;\r\n+    \r\n+    for(int y = 0; y < 16; y++) {\r\n+        for(int x = 0; x < 16; x++) {\r\n+            float distance = sqrt((x - centerX) * (x - centerX) + \r\n+                                (y - centerY) * (y - centerY));\r\n+            \r\n+            uint8_t brightness = 0;\r\n+            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n+                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n+                brightness += sin8(wavePhase) / numWaves;\r\n+            }\r\n+            \r\n+            // Fix: Cast float to int before modulo\r\n+            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n+            \r\n+            if(brightness > 30) {\r\n+                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+            } else {\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740855823296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,297 @@\n+#include \"globals.h\"\r\n+#include \"animations.h\"\r\n+#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n+#define NUM_BLOCKS 3\r\n+\r\n+static unsigned long lastRandomBlockUpdate = 0;\r\n+\r\n+/**\r\n+ * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n+ */\r\n+void randomBlock() {\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n+        FastLED.clear();\r\n+        // Light up random blocks\r\n+        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n+            int x = random(0, BUTTON_ROWS);\r\n+            int y = random(0, BUTTON_COLS);\r\n+            CRGB color = CHSV(random(255), 255, 255);\r\n+            setButtonColor(x, y, color);\r\n+        }\r\n+        FastLED.show();\r\n+        lastRandomBlockUpdate = currentTime;\r\n+    }\r\n+}\r\n+\r\n+#ifdef RAINBOW_SNAKE\r\n+unsigned long lastFoodTime = 0;\r\n+int foodX = -1;\r\n+int foodY = -1;\r\n+const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n+\r\n+/**\r\n+ * Spawns food at a random location on the LED matrix.\r\n+ * Food is represented by a red LED.\r\n+ * @param state The current state of the snake animation.\r\n+ */\r\n+static void spawn_food(SnakeState* state) {\r\n+    do {\r\n+        state->foodX = random(0, 16);\r\n+        state->foodY = random(0, 16);\r\n+    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+}\r\n+\r\n+/**\r\n+ * Initializes the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n+ */\r\n+void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n+    state->x = random(0, 16);\r\n+    state->y = random(0, 16);\r\n+    state->dx = 1;\r\n+    state->dy = 0;\r\n+    state->snakeLength = 8;\r\n+    state->pathIndex = 0;\r\n+    state->lastFoodTime = millis();\r\n+    state->lastUpdate = millis();\r\n+    state->isActive = true;\r\n+    state->wrapAround = wrapAround;\r\n+    FastLED.clear();\r\n+    spawn_food(state);\r\n+}\r\n+\r\n+/**\r\n+ * Updates the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ */\r\n+void snake_update(SnakeState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - state->lastUpdate < 40) return;\r\n+\r\n+    // Spawn food at interval if necessary\r\n+    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    // Check if we need to spawn food after eating\r\n+    bool ateFood = false;\r\n+\r\n+    // Movement logic with collision detection\r\n+    bool moved = false;\r\n+    int directions[6][2];\r\n+    int dirIndex = 0;\r\n+\r\n+    // Weight current direction\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+\r\n+    // Add other directions\r\n+    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n+    for (int k = 0; k < 4; k++) {\r\n+        int pdx = possibleDirections[k][0];\r\n+        int pdy = possibleDirections[k][1];\r\n+        if (pdx != state->dx || pdy != state->dy) {\r\n+            directions[dirIndex][0] = pdx;\r\n+            directions[dirIndex][1] = pdy;\r\n+            dirIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    // Shuffle directions\r\n+    for (int s = 0; s < dirIndex; s++) {\r\n+        int r = random(s, dirIndex);\r\n+        int tempDx = directions[s][0];\r\n+        int tempDy = directions[s][1];\r\n+        directions[s][0] = directions[r][0];\r\n+        directions[s][1] = directions[r][1];\r\n+        directions[r][0] = tempDx;\r\n+        directions[r][1] = tempDy;\r\n+    }\r\n+\r\n+    // Try each direction\r\n+    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n+        int newDx = directions[attempt][0];\r\n+        int newDy = directions[attempt][1];\r\n+        int newX = state->x + newDx;\r\n+        int newY = state->y + newDy;\r\n+\r\n+        if (state->wrapAround) {\r\n+            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n+            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n+                continue;\r\n+            }\r\n+        }\r\n+\r\n+        // Check collision with body\r\n+        bool collision = false;\r\n+        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n+        for (int j = 0; j < checkLength; j++) {\r\n+            int idx = (state->pathIndex - j + 256) % 256;\r\n+            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n+                collision = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!collision) {\r\n+            state->x = newX;\r\n+            state->y = newY;\r\n+            state->dx = newDx;\r\n+            state->dy = newDy;\r\n+            moved = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (!moved) {\r\n+        // Reverse if stuck\r\n+        state->dx = -state->dx;\r\n+        state->dy = -state->dy;\r\n+        state->x += state->dx;\r\n+        state->y += state->dy;\r\n+        // Handle wrap around\r\n+        if (state->wrapAround) {\r\n+            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n+            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (state->x < 0) state->x = 0;\r\n+            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n+            if (state->y < 0) state->y = 0;\r\n+            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // Record position after moving\r\n+    state->path[state->pathIndex][0] = state->x;\r\n+    state->path[state->pathIndex][1] = state->y;\r\n+\r\n+    // Check food collision\r\n+    if (state->x == state->foodX && state->y == state->foodY) {\r\n+        state->snakeLength++;\r\n+        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n+        ateFood = true;\r\n+    }\r\n+\r\n+    // Set current LED with rainbow effect\r\n+    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+\r\n+    // Clear tail\r\n+    if (state->snakeLength < 256) {\r\n+        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n+        int tailX = state->path[tailIndex][0];\r\n+        int tailY = state->path[tailIndex][1];\r\n+        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n+    }\r\n+\r\n+    // Update path index\r\n+    state->pathIndex = (state->pathIndex + 1) % 256;\r\n+\r\n+    // Spawn new food if ate\r\n+    if (ateFood) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+    state->lastUpdate = currentTime;\r\n+}\r\n+#endif\r\n+\r\n+/**\r\n+ * Basic snake animation that follows the Original LED matrix indexing.\r\n+ */\r\n+void rainbow_snake_old() {\r\n+    // light up a rainbow snake of length 8, \r\n+    for (int i = 0; i < NUM_LEDS; i++) {\r\n+        leds[i] = CHSV(i, 255, 255);\r\n+        FastLED.show();\r\n+        delay(10);\r\n+        if (i % 8 == 0) {\r\n+        leds[i] = CRGB::Purple;\r\n+        }\r\n+        // clear leds at i - 8\r\n+        if (i >= 8) {\r\n+        leds[i - 8] = CRGB::Black;\r\n+        } else {\r\n+        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void display_logo() {\r\n+    // Iterate over each byte in the FHMS_LOGO array\r\n+    for (int i = 0; i < 32; i++) {\r\n+        unsigned char byte = FHMS_LOGO[i];\r\n+        // Each byte contains 8 bits\r\n+        for (int bit = 0; bit < 8; bit++) {\r\n+            int bitIndex = i * 8 + bit;\r\n+            int x = bitIndex % 16;\r\n+            int y = bitIndex / 16;\r\n+\r\n+            // Check if the current bit is set\r\n+            if (byte & (0x80 >> bit)) {\r\n+                // Set the LED to white if the bit is 1\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n+            } else {\r\n+                // Turn off the LED if the bit is 0\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n+            }\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+}\r\n+\r\n+void idle_animation() {\r\n+    static uint16_t hueOffset = 0;\r\n+    for (int y = 0; y < 6; y++) {\r\n+        for (int x = 0; x < 6; x++) {\r\n+            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n+            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+    hueOffset += 1;\r\n+}\r\n+\r\n+void wave_ripple_animation() {\r\n+    static uint8_t timeOffset = 0;\r\n+    static const uint8_t numWaves = 3;\r\n+    const uint8_t centerX = 8;\r\n+    const uint8_t centerY = 8;\r\n+    \r\n+    for(int y = 0; y < 6; y++) {\r\n+        for(int x = 0; x < 16; x++) {\r\n+            float distance = sqrt((x - centerX) * (x - centerX) + \r\n+                                (y - centerY) * (y - centerY));\r\n+            \r\n+            uint8_t brightness = 0;\r\n+            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n+                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n+                brightness += sin8(wavePhase) / numWaves;\r\n+            }\r\n+            \r\n+            // Fix: Cast float to int before modulo\r\n+            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n+            \r\n+            if(brightness > 30) {\r\n+                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+            } else {\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740856070005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,31 +228,8 @@\n         }\r\n     }\r\n }\r\n \r\n-void display_logo() {\r\n-    // Iterate over each byte in the FHMS_LOGO array\r\n-    for (int i = 0; i < 32; i++) {\r\n-        unsigned char byte = FHMS_LOGO[i];\r\n-        // Each byte contains 8 bits\r\n-        for (int bit = 0; bit < 8; bit++) {\r\n-            int bitIndex = i * 8 + bit;\r\n-            int x = bitIndex % 16;\r\n-            int y = bitIndex / 16;\r\n-\r\n-            // Check if the current bit is set\r\n-            if (byte & (0x80 >> bit)) {\r\n-                // Set the LED to white if the bit is 1\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n-            } else {\r\n-                // Turn off the LED if the bit is 0\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n-            }\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-}\r\n-\r\n void idle_animation() {\r\n     static uint16_t hueOffset = 0;\r\n     for (int y = 0; y < 6; y++) {\r\n         for (int x = 0; x < 6; x++) {\r\n@@ -270,9 +247,9 @@\n     const uint8_t centerX = 8;\r\n     const uint8_t centerY = 8;\r\n     \r\n     for(int y = 0; y < 6; y++) {\r\n-        for(int x = 0; x < 16; x++) {\r\n+        for(int x = 0; x < 6; x++) {\r\n             float distance = sqrt((x - centerX) * (x - centerX) + \r\n                                 (y - centerY) * (y - centerY));\r\n             \r\n             uint8_t brightness = 0;\r\n@@ -293,599 +270,5 @@\n     }\r\n     \r\n     FastLED.show();\r\n     timeOffset += 2;\r\n-}\n-#include \"globals.h\"\r\n-#include \"animations.h\"\r\n-#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 3\r\n-\r\n-static unsigned long lastRandomBlockUpdate = 0;\r\n-\r\n-/**\r\n- * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n- */\r\n-void randomBlock() {\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n-        FastLED.clear();\r\n-        // Light up random blocks\r\n-        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, BUTTON_ROWS);\r\n-            int y = random(0, BUTTON_COLS);\r\n-            CRGB color = CHSV(random(255), 255, 255);\r\n-            setButtonColor(x, y, color);\r\n-        }\r\n-        FastLED.show();\r\n-        lastRandomBlockUpdate = currentTime;\r\n-    }\r\n-}\r\n-\r\n-#ifdef RAINBOW_SNAKE\r\n-unsigned long lastFoodTime = 0;\r\n-int foodX = -1;\r\n-int foodY = -1;\r\n-const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n-\r\n-/**\r\n- * Spawns food at a random location on the LED matrix.\r\n- * Food is represented by a red LED.\r\n- * @param state The current state of the snake animation.\r\n- */\r\n-static void spawn_food(SnakeState* state) {\r\n-    do {\r\n-        state->foodX = random(0, 16);\r\n-        state->foodY = random(0, 16);\r\n-    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n-    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n-}\r\n-\r\n-/**\r\n- * Initializes the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n- */\r\n-void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n-    state->x = random(0, 16);\r\n-    state->y = random(0, 16);\r\n-    state->dx = 1;\r\n-    state->dy = 0;\r\n-    state->snakeLength = 8;\r\n-    state->pathIndex = 0;\r\n-    state->lastFoodTime = millis();\r\n-    state->lastUpdate = millis();\r\n-    state->isActive = true;\r\n-    state->wrapAround = wrapAround;\r\n-    FastLED.clear();\r\n-    spawn_food(state);\r\n-}\r\n-\r\n-/**\r\n- * Updates the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- */\r\n-void snake_update(SnakeState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - state->lastUpdate < 40) return;\r\n-\r\n-    // Spawn food at interval if necessary\r\n-    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    // Check if we need to spawn food after eating\r\n-    bool ateFood = false;\r\n-\r\n-    // Movement logic with collision detection\r\n-    bool moved = false;\r\n-    int directions[6][2];\r\n-    int dirIndex = 0;\r\n-\r\n-    // Weight current direction\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-\r\n-    // Add other directions\r\n-    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n-    for (int k = 0; k < 4; k++) {\r\n-        int pdx = possibleDirections[k][0];\r\n-        int pdy = possibleDirections[k][1];\r\n-        if (pdx != state->dx || pdy != state->dy) {\r\n-            directions[dirIndex][0] = pdx;\r\n-            directions[dirIndex][1] = pdy;\r\n-            dirIndex++;\r\n-        }\r\n-    }\r\n-\r\n-    // Shuffle directions\r\n-    for (int s = 0; s < dirIndex; s++) {\r\n-        int r = random(s, dirIndex);\r\n-        int tempDx = directions[s][0];\r\n-        int tempDy = directions[s][1];\r\n-        directions[s][0] = directions[r][0];\r\n-        directions[s][1] = directions[r][1];\r\n-        directions[r][0] = tempDx;\r\n-        directions[r][1] = tempDy;\r\n-    }\r\n-\r\n-    // Try each direction\r\n-    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n-        int newDx = directions[attempt][0];\r\n-        int newDy = directions[attempt][1];\r\n-        int newX = state->x + newDx;\r\n-        int newY = state->y + newDy;\r\n-\r\n-        if (state->wrapAround) {\r\n-            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n-            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n-        } else {\r\n-            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n-                continue;\r\n-            }\r\n-        }\r\n-\r\n-        // Check collision with body\r\n-        bool collision = false;\r\n-        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n-        for (int j = 0; j < checkLength; j++) {\r\n-            int idx = (state->pathIndex - j + 256) % 256;\r\n-            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n-                collision = true;\r\n-                break;\r\n-            }\r\n-        }\r\n-\r\n-        if (!collision) {\r\n-            state->x = newX;\r\n-            state->y = newY;\r\n-            state->dx = newDx;\r\n-            state->dy = newDy;\r\n-            moved = true;\r\n-        }\r\n-    }\r\n-\r\n-    if (!moved) {\r\n-        // Reverse if stuck\r\n-        state->dx = -state->dx;\r\n-        state->dy = -state->dy;\r\n-        state->x += state->dx;\r\n-        state->y += state->dy;\r\n-        // Handle wrap around\r\n-        if (state->wrapAround) {\r\n-            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n-            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n-        } else {\r\n-            if (state->x < 0) state->x = 0;\r\n-            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n-            if (state->y < 0) state->y = 0;\r\n-            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n-        }\r\n-    }\r\n-\r\n-    // Record position after moving\r\n-    state->path[state->pathIndex][0] = state->x;\r\n-    state->path[state->pathIndex][1] = state->y;\r\n-\r\n-    // Check food collision\r\n-    if (state->x == state->foodX && state->y == state->foodY) {\r\n-        state->snakeLength++;\r\n-        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n-        ateFood = true;\r\n-    }\r\n-\r\n-    // Set current LED with rainbow effect\r\n-    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n-\r\n-    // Clear tail\r\n-    if (state->snakeLength < 256) {\r\n-        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n-        int tailX = state->path[tailIndex][0];\r\n-        int tailY = state->path[tailIndex][1];\r\n-        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n-    }\r\n-\r\n-    // Update path index\r\n-    state->pathIndex = (state->pathIndex + 1) % 256;\r\n-\r\n-    // Spawn new food if ate\r\n-    if (ateFood) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-    state->lastUpdate = currentTime;\r\n-}\r\n-#endif\r\n-\r\n-/**\r\n- * Basic snake animation that follows the Original LED matrix indexing.\r\n- */\r\n-void rainbow_snake_old() {\r\n-    // light up a rainbow snake of length 8, \r\n-    for (int i = 0; i < NUM_LEDS; i++) {\r\n-        leds[i] = CHSV(i, 255, 255);\r\n-        FastLED.show();\r\n-        delay(10);\r\n-        if (i % 8 == 0) {\r\n-        leds[i] = CRGB::Purple;\r\n-        }\r\n-        // clear leds at i - 8\r\n-        if (i >= 8) {\r\n-        leds[i - 8] = CRGB::Black;\r\n-        } else {\r\n-        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void display_logo() {\r\n-    // Iterate over each byte in the FHMS_LOGO array\r\n-    for (int i = 0; i < 32; i++) {\r\n-        unsigned char byte = FHMS_LOGO[i];\r\n-        // Each byte contains 8 bits\r\n-        for (int bit = 0; bit < 8; bit++) {\r\n-            int bitIndex = i * 8 + bit;\r\n-            int x = bitIndex % 16;\r\n-            int y = bitIndex / 16;\r\n-\r\n-            // Check if the current bit is set\r\n-            if (byte & (0x80 >> bit)) {\r\n-                // Set the LED to white if the bit is 1\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n-            } else {\r\n-                // Turn off the LED if the bit is 0\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n-            }\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-}\r\n-\r\n-void idle_animation() {\r\n-    static uint16_t hueOffset = 0;\r\n-    for (int y = 0; y < 6; y++) {\r\n-        for (int x = 0; x < 16; x++) {\r\n-            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n-            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-    hueOffset += 1;\r\n-}\r\n-\r\n-void wave_ripple_animation() {\r\n-    static uint8_t timeOffset = 0;\r\n-    static const uint8_t numWaves = 3;\r\n-    const uint8_t centerX = 8;\r\n-    const uint8_t centerY = 8;\r\n-    \r\n-    for(int y = 0; y < 16; y++) {\r\n-        for(int x = 0; x < 16; x++) {\r\n-            float distance = sqrt((x - centerX) * (x - centerX) + \r\n-                                (y - centerY) * (y - centerY));\r\n-            \r\n-            uint8_t brightness = 0;\r\n-            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n-                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n-                brightness += sin8(wavePhase) / numWaves;\r\n-            }\r\n-            \r\n-            // Fix: Cast float to int before modulo\r\n-            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n-            \r\n-            if(brightness > 30) {\r\n-                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n-            } else {\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    FastLED.show();\r\n-    timeOffset += 2;\r\n-}\n-#include \"globals.h\"\r\n-#include \"animations.h\"\r\n-#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n-#define NUM_BLOCKS 3\r\n-\r\n-static unsigned long lastRandomBlockUpdate = 0;\r\n-\r\n-/**\r\n- * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n- */\r\n-void randomBlock() {\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n-        FastLED.clear();\r\n-        // Light up random blocks\r\n-        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n-            int x = random(0, BUTTON_ROWS);\r\n-            int y = random(0, BUTTON_COLS);\r\n-            CRGB color = CHSV(random(255), 255, 255);\r\n-            setButtonColor(x, y, color);\r\n-        }\r\n-        FastLED.show();\r\n-        lastRandomBlockUpdate = currentTime;\r\n-    }\r\n-}\r\n-\r\n-#ifdef RAINBOW_SNAKE\r\n-unsigned long lastFoodTime = 0;\r\n-int foodX = -1;\r\n-int foodY = -1;\r\n-const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n-\r\n-/**\r\n- * Spawns food at a random location on the LED matrix.\r\n- * Food is represented by a red LED.\r\n- * @param state The current state of the snake animation.\r\n- */\r\n-static void spawn_food(SnakeState* state) {\r\n-    do {\r\n-        state->foodX = random(0, 16);\r\n-        state->foodY = random(0, 16);\r\n-    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n-    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n-}\r\n-\r\n-/**\r\n- * Initializes the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n- */\r\n-void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n-    state->x = random(0, 16);\r\n-    state->y = random(0, 16);\r\n-    state->dx = 1;\r\n-    state->dy = 0;\r\n-    state->snakeLength = 8;\r\n-    state->pathIndex = 0;\r\n-    state->lastFoodTime = millis();\r\n-    state->lastUpdate = millis();\r\n-    state->isActive = true;\r\n-    state->wrapAround = wrapAround;\r\n-    FastLED.clear();\r\n-    spawn_food(state);\r\n-}\r\n-\r\n-/**\r\n- * Updates the snake animation with the given state.\r\n- * @param state The state of the snake animation.\r\n- */\r\n-void snake_update(SnakeState* state) {\r\n-    if (!state->isActive) return;\r\n-\r\n-    unsigned long currentTime = millis();\r\n-    if (currentTime - state->lastUpdate < 40) return;\r\n-\r\n-    // Spawn food at interval if necessary\r\n-    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    // Check if we need to spawn food after eating\r\n-    bool ateFood = false;\r\n-\r\n-    // Movement logic with collision detection\r\n-    bool moved = false;\r\n-    int directions[6][2];\r\n-    int dirIndex = 0;\r\n-\r\n-    // Weight current direction\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-    directions[dirIndex][0] = state->dx;\r\n-    directions[dirIndex][1] = state->dy;\r\n-    dirIndex++;\r\n-\r\n-    // Add other directions\r\n-    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n-    for (int k = 0; k < 4; k++) {\r\n-        int pdx = possibleDirections[k][0];\r\n-        int pdy = possibleDirections[k][1];\r\n-        if (pdx != state->dx || pdy != state->dy) {\r\n-            directions[dirIndex][0] = pdx;\r\n-            directions[dirIndex][1] = pdy;\r\n-            dirIndex++;\r\n-        }\r\n-    }\r\n-\r\n-    // Shuffle directions\r\n-    for (int s = 0; s < dirIndex; s++) {\r\n-        int r = random(s, dirIndex);\r\n-        int tempDx = directions[s][0];\r\n-        int tempDy = directions[s][1];\r\n-        directions[s][0] = directions[r][0];\r\n-        directions[s][1] = directions[r][1];\r\n-        directions[r][0] = tempDx;\r\n-        directions[r][1] = tempDy;\r\n-    }\r\n-\r\n-    // Try each direction\r\n-    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n-        int newDx = directions[attempt][0];\r\n-        int newDy = directions[attempt][1];\r\n-        int newX = state->x + newDx;\r\n-        int newY = state->y + newDy;\r\n-\r\n-        if (state->wrapAround) {\r\n-            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n-            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n-        } else {\r\n-            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n-                continue;\r\n-            }\r\n-        }\r\n-\r\n-        // Check collision with body\r\n-        bool collision = false;\r\n-        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n-        for (int j = 0; j < checkLength; j++) {\r\n-            int idx = (state->pathIndex - j + 256) % 256;\r\n-            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n-                collision = true;\r\n-                break;\r\n-            }\r\n-        }\r\n-\r\n-        if (!collision) {\r\n-            state->x = newX;\r\n-            state->y = newY;\r\n-            state->dx = newDx;\r\n-            state->dy = newDy;\r\n-            moved = true;\r\n-        }\r\n-    }\r\n-\r\n-    if (!moved) {\r\n-        // Reverse if stuck\r\n-        state->dx = -state->dx;\r\n-        state->dy = -state->dy;\r\n-        state->x += state->dx;\r\n-        state->y += state->dy;\r\n-        // Handle wrap around\r\n-        if (state->wrapAround) {\r\n-            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n-            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n-        } else {\r\n-            if (state->x < 0) state->x = 0;\r\n-            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n-            if (state->y < 0) state->y = 0;\r\n-            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n-        }\r\n-    }\r\n-\r\n-    // Record position after moving\r\n-    state->path[state->pathIndex][0] = state->x;\r\n-    state->path[state->pathIndex][1] = state->y;\r\n-\r\n-    // Check food collision\r\n-    if (state->x == state->foodX && state->y == state->foodY) {\r\n-        state->snakeLength++;\r\n-        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n-        ateFood = true;\r\n-    }\r\n-\r\n-    // Set current LED with rainbow effect\r\n-    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n-\r\n-    // Clear tail\r\n-    if (state->snakeLength < 256) {\r\n-        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n-        int tailX = state->path[tailIndex][0];\r\n-        int tailY = state->path[tailIndex][1];\r\n-        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n-    }\r\n-\r\n-    // Update path index\r\n-    state->pathIndex = (state->pathIndex + 1) % 256;\r\n-\r\n-    // Spawn new food if ate\r\n-    if (ateFood) {\r\n-        spawn_food(state);\r\n-        state->lastFoodTime = currentTime;\r\n-    }\r\n-\r\n-    FastLED.show();\r\n-    state->lastUpdate = currentTime;\r\n-}\r\n-#endif\r\n-\r\n-/**\r\n- * Basic snake animation that follows the Original LED matrix indexing.\r\n- */\r\n-void rainbow_snake_old() {\r\n-    // light up a rainbow snake of length 8, \r\n-    for (int i = 0; i < NUM_LEDS; i++) {\r\n-        leds[i] = CHSV(i, 255, 255);\r\n-        FastLED.show();\r\n-        delay(10);\r\n-        if (i % 8 == 0) {\r\n-        leds[i] = CRGB::Purple;\r\n-        }\r\n-        // clear leds at i - 8\r\n-        if (i >= 8) {\r\n-        leds[i - 8] = CRGB::Black;\r\n-        } else {\r\n-        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void display_logo() {\r\n-    // Iterate over each byte in the FHMS_LOGO array\r\n-    for (int i = 0; i < 32; i++) {\r\n-        unsigned char byte = FHMS_LOGO[i];\r\n-        // Each byte contains 8 bits\r\n-        for (int bit = 0; bit < 8; bit++) {\r\n-            int bitIndex = i * 8 + bit;\r\n-            int x = bitIndex % 16;\r\n-            int y = bitIndex / 16;\r\n-\r\n-            // Check if the current bit is set\r\n-            if (byte & (0x80 >> bit)) {\r\n-                // Set the LED to white if the bit is 1\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n-            } else {\r\n-                // Turn off the LED if the bit is 0\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Blue;\r\n-            }\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-}\r\n-\r\n-void idle_animation() {\r\n-    static uint16_t hueOffset = 0;\r\n-    for (int y = 0; y < 16; y++) {\r\n-        for (int x = 0; x < 16; x++) {\r\n-            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n-            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n-        }\r\n-    }\r\n-    FastLED.show();\r\n-    hueOffset += 1;\r\n-}\r\n-\r\n-void wave_ripple_animation() {\r\n-    static uint8_t timeOffset = 0;\r\n-    static const uint8_t numWaves = 3;\r\n-    const uint8_t centerX = 8;\r\n-    const uint8_t centerY = 8;\r\n-    \r\n-    for(int y = 0; y < 16; y++) {\r\n-        for(int x = 0; x < 16; x++) {\r\n-            float distance = sqrt((x - centerX) * (x - centerX) + \r\n-                                (y - centerY) * (y - centerY));\r\n-            \r\n-            uint8_t brightness = 0;\r\n-            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n-                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n-                brightness += sin8(wavePhase) / numWaves;\r\n-            }\r\n-            \r\n-            // Fix: Cast float to int before modulo\r\n-            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n-            \r\n-            if(brightness > 30) {\r\n-                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n-            } else {\r\n-                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    FastLED.show();\r\n-    timeOffset += 2;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740904748510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,8 +23,10 @@\n         lastRandomBlockUpdate = currentTime;\r\n     }\r\n }\r\n \r\n+void \r\n+\r\n #ifdef RAINBOW_SNAKE\r\n unsigned long lastFoodTime = 0;\r\n int foodX = -1;\r\n int foodY = -1;\r\n"
                },
                {
                    "date": 1740904755325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,5 +272,7 @@\n             }\r\n         }\r\n     }\r\n     \r\n-    FastLED.show(\n\\ No newline at end of file\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740904765954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,281 @@\n+#include \"globals.h\"\r\n+#include \"animations.h\"\r\n+#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n+#define NUM_BLOCKS 3\r\n+\r\n+static unsigned long lastRandomBlockUpdate = 0;\r\n+\r\n+/**\r\n+ * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n+ */\r\n+void randomBlock() {\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n+        FastLED.clear();\r\n+        // Light up random blocks\r\n+        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n+            int x = random(0, BUTTON_ROWS);\r\n+            int y = random(0, BUTTON_COLS);\r\n+            CRGB color = CHSV(random(255), 255, 255);\r\n+            setButtonColor(x, y, color);\r\n+        }\r\n+        FastLED.show();\r\n+        lastRandomBlockUpdate = currentTime;\r\n+    }\r\n+}\r\n+\r\n+/**\r\n+ * Lights up a rainbow border around the LED matrix.\r\n+ */\r\n+void rainbowBorder () {\r\n+\r\n+}\r\n+\r\n+#ifdef RAINBOW_SNAKE\r\n+unsigned long lastFoodTime = 0;\r\n+int foodX = -1;\r\n+int foodY = -1;\r\n+const unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n+\r\n+/**\r\n+ * Spawns food at a random location on the LED matrix.\r\n+ * Food is represented by a red LED.\r\n+ * @param state The current state of the snake animation.\r\n+ */\r\n+static void spawn_food(SnakeState* state) {\r\n+    do {\r\n+        state->foodX = random(0, 16);\r\n+        state->foodY = random(0, 16);\r\n+    } while (leds[ButtonMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n+    leds[ButtonMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n+}\r\n+\r\n+/**\r\n+ * Initializes the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n+ */\r\n+void snake_animation_init(SnakeState* state, bool wrapAround) {\r\n+    state->x = random(0, 16);\r\n+    state->y = random(0, 16);\r\n+    state->dx = 1;\r\n+    state->dy = 0;\r\n+    state->snakeLength = 8;\r\n+    state->pathIndex = 0;\r\n+    state->lastFoodTime = millis();\r\n+    state->lastUpdate = millis();\r\n+    state->isActive = true;\r\n+    state->wrapAround = wrapAround;\r\n+    FastLED.clear();\r\n+    spawn_food(state);\r\n+}\r\n+\r\n+/**\r\n+ * Updates the snake animation with the given state.\r\n+ * @param state The state of the snake animation.\r\n+ */\r\n+void snake_update(SnakeState* state) {\r\n+    if (!state->isActive) return;\r\n+\r\n+    unsigned long currentTime = millis();\r\n+    if (currentTime - state->lastUpdate < 40) return;\r\n+\r\n+    // Spawn food at interval if necessary\r\n+    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    // Check if we need to spawn food after eating\r\n+    bool ateFood = false;\r\n+\r\n+    // Movement logic with collision detection\r\n+    bool moved = false;\r\n+    int directions[6][2];\r\n+    int dirIndex = 0;\r\n+\r\n+    // Weight current direction\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+    directions[dirIndex][0] = state->dx;\r\n+    directions[dirIndex][1] = state->dy;\r\n+    dirIndex++;\r\n+\r\n+    // Add other directions\r\n+    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n+    for (int k = 0; k < 4; k++) {\r\n+        int pdx = possibleDirections[k][0];\r\n+        int pdy = possibleDirections[k][1];\r\n+        if (pdx != state->dx || pdy != state->dy) {\r\n+            directions[dirIndex][0] = pdx;\r\n+            directions[dirIndex][1] = pdy;\r\n+            dirIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    // Shuffle directions\r\n+    for (int s = 0; s < dirIndex; s++) {\r\n+        int r = random(s, dirIndex);\r\n+        int tempDx = directions[s][0];\r\n+        int tempDy = directions[s][1];\r\n+        directions[s][0] = directions[r][0];\r\n+        directions[s][1] = directions[r][1];\r\n+        directions[r][0] = tempDx;\r\n+        directions[r][1] = tempDy;\r\n+    }\r\n+\r\n+    // Try each direction\r\n+    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n+        int newDx = directions[attempt][0];\r\n+        int newDy = directions[attempt][1];\r\n+        int newX = state->x + newDx;\r\n+        int newY = state->y + newDy;\r\n+\r\n+        if (state->wrapAround) {\r\n+            newX = (newX + BUTTON_COLS) % BUTTON_COLS;\r\n+            newY = (newY + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (newX < 0 || newX >= BUTTON_COLS || newY < 0 || newY >= BUTTON_ROWS) {\r\n+                continue;\r\n+            }\r\n+        }\r\n+\r\n+        // Check collision with body\r\n+        bool collision = false;\r\n+        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n+        for (int j = 0; j < checkLength; j++) {\r\n+            int idx = (state->pathIndex - j + 256) % 256;\r\n+            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n+                collision = true;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!collision) {\r\n+            state->x = newX;\r\n+            state->y = newY;\r\n+            state->dx = newDx;\r\n+            state->dy = newDy;\r\n+            moved = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (!moved) {\r\n+        // Reverse if stuck\r\n+        state->dx = -state->dx;\r\n+        state->dy = -state->dy;\r\n+        state->x += state->dx;\r\n+        state->y += state->dy;\r\n+        // Handle wrap around\r\n+        if (state->wrapAround) {\r\n+            state->x = (state->x + BUTTON_COLS) % BUTTON_COLS;\r\n+            state->y = (state->y + BUTTON_ROWS) % BUTTON_ROWS;\r\n+        } else {\r\n+            if (state->x < 0) state->x = 0;\r\n+            if (state->x >= BUTTON_COLS) state->x = BUTTON_COLS - 1;\r\n+            if (state->y < 0) state->y = 0;\r\n+            if (state->y >= BUTTON_ROWS) state->y = BUTTON_ROWS - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // Record position after moving\r\n+    state->path[state->pathIndex][0] = state->x;\r\n+    state->path[state->pathIndex][1] = state->y;\r\n+\r\n+    // Check food collision\r\n+    if (state->x == state->foodX && state->y == state->foodY) {\r\n+        state->snakeLength++;\r\n+        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n+        ateFood = true;\r\n+    }\r\n+\r\n+    // Set current LED with rainbow effect\r\n+    leds[ButtonMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n+\r\n+    // Clear tail\r\n+    if (state->snakeLength < 256) {\r\n+        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n+        int tailX = state->path[tailIndex][0];\r\n+        int tailY = state->path[tailIndex][1];\r\n+        leds[ButtonMatrix[tailX][tailY]] = CRGB::Black;\r\n+    }\r\n+\r\n+    // Update path index\r\n+    state->pathIndex = (state->pathIndex + 1) % 256;\r\n+\r\n+    // Spawn new food if ate\r\n+    if (ateFood) {\r\n+        spawn_food(state);\r\n+        state->lastFoodTime = currentTime;\r\n+    }\r\n+\r\n+    FastLED.show();\r\n+    state->lastUpdate = currentTime;\r\n+}\r\n+#endif\r\n+\r\n+/**\r\n+ * Basic snake animation that follows the Original LED matrix indexing.\r\n+ */\r\n+void rainbow_snake_old() {\r\n+    // light up a rainbow snake of length 8, \r\n+    for (int i = 0; i < NUM_LEDS; i++) {\r\n+        leds[i] = CHSV(i, 255, 255);\r\n+        FastLED.show();\r\n+        delay(10);\r\n+        if (i % 8 == 0) {\r\n+        leds[i] = CRGB::Purple;\r\n+        }\r\n+        // clear leds at i - 8\r\n+        if (i >= 8) {\r\n+        leds[i - 8] = CRGB::Black;\r\n+        } else {\r\n+        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void idle_animation() {\r\n+    static uint16_t hueOffset = 0;\r\n+    for (int y = 0; y < 6; y++) {\r\n+        for (int x = 0; x < 6; x++) {\r\n+            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n+            leds[ButtonMatrix[x][y]] = CHSV(hue, 255, 255);\r\n+        }\r\n+    }\r\n+    FastLED.show();\r\n+    hueOffset += 1;\r\n+}\r\n+\r\n+void wave_ripple_animation() {\r\n+    static uint8_t timeOffset = 0;\r\n+    static const uint8_t numWaves = 3;\r\n+    const uint8_t centerX = 8;\r\n+    const uint8_t centerY = 8;\r\n+    \r\n+    for(int y = 0; y < 6; y++) {\r\n+        for(int x = 0; x < 6; x++) {\r\n+            float distance = sqrt((x - centerX) * (x - centerX) + \r\n+                                (y - centerY) * (y - centerY));\r\n+            \r\n+            uint8_t brightness = 0;\r\n+            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n+                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n+                brightness += sin8(wavePhase) / numWaves;\r\n+            }\r\n+            \r\n+            // Fix: Cast float to int before modulo\r\n+            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n+            \r\n+            if(brightness > 30) {\r\n+                leds[ButtonMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n+            } else {\r\n+                leds[ButtonMatrix[x][y]] = CRGB::Black;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    FastLED.show();\r\n+    timeOffset += 2;\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1740852719345,
            "name": "Commit-0",
            "content": "#include \"globals.h\"\r\n#include \"animations.h\"\r\n#define RANDOM_BLOCK_INTERVAL 1000  // 1 second between updates\r\n#define NUM_BLOCKS 3\r\n\r\nstatic unsigned long lastRandomBlockUpdate = 0;\r\n\r\n/**\r\n * Lights up, up to NUM_BLOCKS random blocks with random colors.\r\n */\r\nvoid randomBlock() {\r\n    unsigned long currentTime = millis();\r\n    if (currentTime - lastRandomBlockUpdate >= RANDOM_BLOCK_INTERVAL) {\r\n        FastLED.clear();\r\n        // Light up random blocks\r\n        for (int i = 0; i < NUM_BLOCKS; i++) {\r\n            int x = random(0, 3);\r\n            int y = random(0, 3);\r\n            CRGB color = CHSV(random(255), 255, 255);\r\n            setBlockColor(x, y, color);\r\n        }\r\n        FastLED.show();\r\n        lastRandomBlockUpdate = currentTime;\r\n    }\r\n}\r\n\r\n#ifdef RAINBOW_SNAKE\r\nunsigned long lastFoodTime = 0;\r\nint foodX = -1;\r\nint foodY = -1;\r\nconst unsigned long FOOD_INTERVAL = 5000; // 5 seconds in milliseconds\r\n\r\n/**\r\n * Spawns food at a random location on the LED matrix.\r\n * Food is represented by a red LED.\r\n * @param state The current state of the snake animation.\r\n */\r\nstatic void spawn_food(SnakeState* state) {\r\n    do {\r\n        state->foodX = random(0, 16);\r\n        state->foodY = random(0, 16);\r\n    } while (leds[LEDMatrix[state->foodX][state->foodY]] != CRGB::Black);\r\n    leds[LEDMatrix[state->foodX][state->foodY]] = CRGB::Red;\r\n}\r\n\r\n/**\r\n * Initializes the snake animation with the given state.\r\n * @param state The state of the snake animation.\r\n * @param wrapAround Whether the snake should wrap around the LED matrix.\r\n */\r\nvoid snake_animation_init(SnakeState* state, bool wrapAround) {\r\n    state->x = random(0, 16);\r\n    state->y = random(0, 16);\r\n    state->dx = 1;\r\n    state->dy = 0;\r\n    state->snakeLength = 8;\r\n    state->pathIndex = 0;\r\n    state->lastFoodTime = millis();\r\n    state->lastUpdate = millis();\r\n    state->isActive = true;\r\n    state->wrapAround = wrapAround;\r\n    FastLED.clear();\r\n    spawn_food(state);\r\n}\r\n\r\n/**\r\n * Updates the snake animation with the given state.\r\n * @param state The state of the snake animation.\r\n */\r\nvoid snake_update(SnakeState* state) {\r\n    if (!state->isActive) return;\r\n\r\n    unsigned long currentTime = millis();\r\n    if (currentTime - state->lastUpdate < 40) return;\r\n\r\n    // Spawn food at interval if necessary\r\n    if (currentTime - state->lastFoodTime >= FOOD_INTERVAL) {\r\n        spawn_food(state);\r\n        state->lastFoodTime = currentTime;\r\n    }\r\n\r\n    // Check if we need to spawn food after eating\r\n    bool ateFood = false;\r\n\r\n    // Movement logic with collision detection\r\n    bool moved = false;\r\n    int directions[6][2];\r\n    int dirIndex = 0;\r\n\r\n    // Weight current direction\r\n    directions[dirIndex][0] = state->dx;\r\n    directions[dirIndex][1] = state->dy;\r\n    dirIndex++;\r\n    directions[dirIndex][0] = state->dx;\r\n    directions[dirIndex][1] = state->dy;\r\n    dirIndex++;\r\n\r\n    // Add other directions\r\n    int possibleDirections[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n    for (int k = 0; k < 4; k++) {\r\n        int pdx = possibleDirections[k][0];\r\n        int pdy = possibleDirections[k][1];\r\n        if (pdx != state->dx || pdy != state->dy) {\r\n            directions[dirIndex][0] = pdx;\r\n            directions[dirIndex][1] = pdy;\r\n            dirIndex++;\r\n        }\r\n    }\r\n\r\n    // Shuffle directions\r\n    for (int s = 0; s < dirIndex; s++) {\r\n        int r = random(s, dirIndex);\r\n        int tempDx = directions[s][0];\r\n        int tempDy = directions[s][1];\r\n        directions[s][0] = directions[r][0];\r\n        directions[s][1] = directions[r][1];\r\n        directions[r][0] = tempDx;\r\n        directions[r][1] = tempDy;\r\n    }\r\n\r\n    // Try each direction\r\n    for (int attempt = 0; attempt < dirIndex && !moved; attempt++) {\r\n        int newDx = directions[attempt][0];\r\n        int newDy = directions[attempt][1];\r\n        int newX = state->x + newDx;\r\n        int newY = state->y + newDy;\r\n\r\n        if (state->wrapAround) {\r\n            newX = (newX + LED_COLS) % LED_COLS;\r\n            newY = (newY + LED_ROWS) % LED_ROWS;\r\n        } else {\r\n            if (newX < 0 || newX >= LED_COLS || newY < 0 || newY >= LED_ROWS) {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Check collision with body\r\n        bool collision = false;\r\n        int checkLength = (state->snakeLength < 256) ? state->snakeLength : 255;\r\n        for (int j = 0; j < checkLength; j++) {\r\n            int idx = (state->pathIndex - j + 256) % 256;\r\n            if (state->path[idx][0] == newX && state->path[idx][1] == newY) {\r\n                collision = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!collision) {\r\n            state->x = newX;\r\n            state->y = newY;\r\n            state->dx = newDx;\r\n            state->dy = newDy;\r\n            moved = true;\r\n        }\r\n    }\r\n\r\n    if (!moved) {\r\n        // Reverse if stuck\r\n        state->dx = -state->dx;\r\n        state->dy = -state->dy;\r\n        state->x += state->dx;\r\n        state->y += state->dy;\r\n        // Handle wrap around\r\n        if (state->wrapAround) {\r\n            state->x = (state->x + LED_COLS) % LED_COLS;\r\n            state->y = (state->y + LED_ROWS) % LED_ROWS;\r\n        } else {\r\n            if (state->x < 0) state->x = 0;\r\n            if (state->x >= LED_COLS) state->x = LED_COLS - 1;\r\n            if (state->y < 0) state->y = 0;\r\n            if (state->y >= LED_ROWS) state->y = LED_ROWS - 1;\r\n        }\r\n    }\r\n\r\n    // Record position after moving\r\n    state->path[state->pathIndex][0] = state->x;\r\n    state->path[state->pathIndex][1] = state->y;\r\n\r\n    // Check food collision\r\n    if (state->x == state->foodX && state->y == state->foodY) {\r\n        state->snakeLength++;\r\n        if (state->snakeLength >= 200) state->snakeLength = 8;\r\n        ateFood = true;\r\n    }\r\n\r\n    // Set current LED with rainbow effect\r\n    leds[LEDMatrix[state->x][state->y]] = CHSV(state->pathIndex % 255, 255, 255);\r\n\r\n    // Clear tail\r\n    if (state->snakeLength < 256) {\r\n        int tailIndex = (state->pathIndex - state->snakeLength + 256) % 256;\r\n        int tailX = state->path[tailIndex][0];\r\n        int tailY = state->path[tailIndex][1];\r\n        leds[LEDMatrix[tailX][tailY]] = CRGB::Black;\r\n    }\r\n\r\n    // Update path index\r\n    state->pathIndex = (state->pathIndex + 1) % 256;\r\n\r\n    // Spawn new food if ate\r\n    if (ateFood) {\r\n        spawn_food(state);\r\n        state->lastFoodTime = currentTime;\r\n    }\r\n\r\n    FastLED.show();\r\n    state->lastUpdate = currentTime;\r\n}\r\n#endif\r\n\r\n/**\r\n * Basic snake animation that follows the Original LED matrix indexing.\r\n */\r\nvoid rainbow_snake_old() {\r\n    // light up a rainbow snake of length 8, \r\n    for (int i = 0; i < NUM_LEDS; i++) {\r\n        leds[i] = CHSV(i, 255, 255);\r\n        FastLED.show();\r\n        delay(10);\r\n        if (i % 8 == 0) {\r\n        leds[i] = CRGB::Purple;\r\n        }\r\n        // clear leds at i - 8\r\n        if (i >= 8) {\r\n        leds[i - 8] = CRGB::Black;\r\n        } else {\r\n        leds[i + NUM_LEDS - 8] = CRGB::Black;\r\n        }\r\n    }\r\n}\r\n\r\nvoid display_logo() {\r\n    // Iterate over each byte in the FHMS_LOGO array\r\n    for (int i = 0; i < 32; i++) {\r\n        unsigned char byte = FHMS_LOGO[i];\r\n        // Each byte contains 8 bits\r\n        for (int bit = 0; bit < 8; bit++) {\r\n            int bitIndex = i * 8 + bit;\r\n            int x = bitIndex % 16;\r\n            int y = bitIndex / 16;\r\n\r\n            // Check if the current bit is set\r\n            if (byte & (0x80 >> bit)) {\r\n                // Set the LED to white if the bit is 1\r\n                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n            } else {\r\n                // Turn off the LED if the bit is 0\r\n                leds[LEDMatrix[x][y]] = CRGB::Blue;\r\n            }\r\n        }\r\n    }\r\n    FastLED.show();\r\n}\r\n\r\nvoid idle_animation() {\r\n    static uint16_t hueOffset = 0;\r\n    for (int y = 0; y < 16; y++) {\r\n        for (int x = 0; x < 16; x++) {\r\n            uint8_t hue = (x * 16 + y * 16 + hueOffset) % 256;\r\n            leds[LEDMatrix[x][y]] = CHSV(hue, 255, 255);\r\n        }\r\n    }\r\n    FastLED.show();\r\n    hueOffset += 1;\r\n}\r\n\r\nvoid wave_ripple_animation() {\r\n    static uint8_t timeOffset = 0;\r\n    static const uint8_t numWaves = 3;\r\n    const uint8_t centerX = 8;\r\n    const uint8_t centerY = 8;\r\n    \r\n    for(int y = 0; y < 16; y++) {\r\n        for(int x = 0; x < 16; x++) {\r\n            float distance = sqrt((x - centerX) * (x - centerX) + \r\n                                (y - centerY) * (y - centerY));\r\n            \r\n            uint8_t brightness = 0;\r\n            for(uint8_t wave = 0; wave < numWaves; wave++) {\r\n                float wavePhase = distance * 0.7 - (timeOffset + wave * 85);\r\n                brightness += sin8(wavePhase) / numWaves;\r\n            }\r\n            \r\n            // Fix: Cast float to int before modulo\r\n            uint8_t hue = (uint8_t)(int(distance * 12) + timeOffset) % 256;\r\n            \r\n            if(brightness > 30) {\r\n                leds[LEDMatrix[x][y]] = CHSV(hue, 255, brightness);\r\n            } else {\r\n                leds[LEDMatrix[x][y]] = CRGB::Black;\r\n            }\r\n        }\r\n    }\r\n    \r\n    FastLED.show();\r\n    timeOffset += 2;\r\n}"
        }
    ]
}